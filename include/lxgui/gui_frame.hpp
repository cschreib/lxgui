#ifndef LXGUI_GUI_FRAME_HPP
#define LXGUI_GUI_FRAME_HPP

#include "lxgui/gui_backdrop.hpp"
#include "lxgui/gui_event_receiver.hpp"
#include "lxgui/gui_frame_core_attributes.hpp"
#include "lxgui/gui_layered_region.hpp"
#include "lxgui/gui_region.hpp"
#include "lxgui/input_keys.hpp"
#include "lxgui/lxgui.hpp"
#include "lxgui/utils.hpp"
#include "lxgui/utils_meta.hpp"
#include "lxgui/utils_signal.hpp"
#include "lxgui/utils_view.hpp"

#include <functional>
#include <limits>
#include <list>
#include <lxgui/extern_sol2_protected_function.hpp>
#include <set>
#include <unordered_map>
#include <vector>

namespace lxgui::gui {

class frame_renderer;
class frame;

/// Contains gui::layered_region
struct layer_container {
    bool                                             is_disabled = false;
    std::vector<utils::observer_ptr<layered_region>> region_list;
};

/// Holds file/line information for a script.
struct script_info {
    std::string file_name;
    std::size_t line_nbr = 0;
};

/// Signature of frame scripts.
using script_signature = void(frame&, const event_data&);

/// Signal type for scripts (used internally).
using script_signal = utils::signal<script_signature>;

/// C++ function type for UI script handlers.
using script_function = script_signal::function_type;

/// View into all the connected scripts for a given event.
using script_list_view = script_signal::slot_list_view;

/**
 * \brief A #region that can contain other regions and react to events.
 * \details This class, which is at the core of the UI design, can contain
 * other frames as "children", and layered regions sorted by layers
 * (text, images, ...). A frame can also react to events, and register
 * callbacks to be executed on particular events (key presses, etc.)
 * or on every tick.
 *
 * Each frame has an optional "title region", which can be used to
 * define and draw a title bar. This title bar can then be used to
 * move the frame around the screen using mouse click and drag.
 * Furthermore, frames have optional support for resizing by click
 * and drag on corners or edges (opt in).
 *
 * Frames can either move freely on the screen, or be "clamped" to the
 * screen so they cannot be partly outside of their render area.
 *
 * __Rendering.__ Frames are grouped into different "strata", which are
 * rendered sequentially. Frames in a high strata will always be rendered
 * above frames in a low strata. Then, within a strata, frames are further
 * sorted by "level"; within this particular strata, a frame with a high
 * level will always be rendered above all frames with a lower level, but
 * it will still remain below other frames in a higher strata. The level
 * of a frame is automatically set to the maximum level inside the strata
 * when the frame is clicked, which effectively brings the frame to the
 * front.
 *
 * __Children and regions.__ When a frame is hidden, all its children
 * and regions will also be hidden. Likewise, deleting a frame will
 * automatically delete all its children and regions, unless they are
 * detached first. Other than this, children and regions do not need to
 * be located inside the frame; this is controlled purely by their anchors.
 * Therefore, if a child is not anchored to its parent, moving the parent
 * will not automatically move the child.
 *
 * __Events.__ Frames can react to events. For this to happen, a callback
 * function must be registered to handle the corresponding event. There are
 * two types of events. First: hard-coded UI events such as `OnKeyPress`
 * or `OnUpdate`, which are automatically triggered by lxgui. Second:
 * generic events, which can be triggered from various sources and all
 * forwarded to the `OnEvent` callback. Generic events are typically
 * generated by whatever application is being driven by lxgui (i.e., your
 * game), and they enable application-specific behavior (for example:
 * changing the UI when the player is under attack will likely require an
 * `"UNDER_ATTACK"` event).
 *
 * To use the first type of events (hard-coded events), all you have to
 * do in general is register a callback function using frame::set_script.
 * However, some hard-coded events require explicit enabling. In particular:
 *
 * - Events related to keyboard input (`OnKeyDown`, `OnKeyRepeat`, `OnKeyUp`)
 * require frame::enable_keyboard, and either focus (see @ref frame::set_focus) or
 * explicit key capture (@ref frame::enable_key_capture).
 * - Events related to mouse click input (`OnDragStart`, `OnDragStop`,
 * `OnMouseUp`, `OnMouseDown`) require frame::enable_mouse_click.
 * - Events related to mouse move input (`OnEnter`, `OnLeave`, `OnMouseMove`)
 * require frame::enable_mouse_move.
 * - Events related to mouse wheel input (`OnMouseWheel`) require
 * frame::enable_mouse_wheel.
 *
 * To use the second type of events (generic events), you have to register
 * a callback for `OnEvent` _and_ register the frame for each generic event
 * you wish to listen to. This is done with frame::register_event.
 *
 * Some events provide arguments to the registered callback function. For
 * example, the application can fire a `"UNIT_ATTACKED"` event when a unit
 * is under attack, and pass the ID of the attacked unit as a first argument,
 * and the ID of the attacker as a second argument. If a callback
 * function is registered using frame::set_script, these arguments can be
 * handled and named like regular function parameters. In layout files
 * "scripts" handlers, they can be accessed with the hard-coded generic names
 * `arg1`, `arg2`, etc.
 *
 * Hard-coded events available to all frames:
 *
 * - `OnChar`: Triggered whenever a character is typed into the frame, and
 * the frame has focus (see @ref frame::set_focus).
 * - `OnDragStart`: Triggered when one of the mouse button registered for
 * dragging (see frame::enable_drag) has been pressed inside the
 * area of the screen occupied by the frame, and a mouse movement is first
 * recorded. This event provides four argument to the registered callback:
 * a number identifying the mouse button that started the drag, the human-readable
 * name of this button, and the mouse X and Y position.
 * - `OnDragMove`: Triggered after `OnDragStart`, each time the mouse moves,
 * until `OnDragStop` is triggered. This event provides four argument to
 * the registered callback: the amount of mouse movement in X and Y since the
 * last call to `OnDragMove` (or since `OnDragStart` if this is the first call),
 * and the mouse X and Y position.
 * - `OnDragStop`: Similar to `OnDragStart`, but triggered when the mouse button
 * is released after `OnDragStart`.
 * - `OnEnter`: Triggered when the mouse pointer enters into the area of
 * the screen occupied by the frame. Note: this only takes into account the
 * position and size of the frame and its title region, but not the space
 * occupied by its children or layered regions. Will not trigger if the
 * frame is hidden.
 * - `OnEvent`: Triggered when a registered generic event occurs. See
 * frame::register_event. To allow distinguishing which event has just
 * been fired, the registered callback function is always provided with a
 * first argument that is set to a string matching the event name. Further
 * arguments can be passed to the callback and are handled as for other events.
 * - `OnFocusGained`: Triggered when the frame gains focus, see
 * frame::set_focus.
 * - `OnFocusLost`: Triggered when the frame looses focus, see
 * frame::set_focus.
 * - `OnHide`: Triggered when region::hide is called, or when the frame
 * is hidden indirectly (for example if its parent is itself hidden). This
 * will only fire if the frame was previously shown.
 * - `OnKeyDown`: Triggered when a keyboard key is pressed. Will only
 * trigger if the frame has focus (see @ref frame::set_focus) or if the key has
 * been registered for capture using @ref frame::enable_key_capture. If no
 * keyboard-enabled frame is focused, only the topmost frame with
 * @ref frame::enable_key_capture will receive the event. If no frame has
 * captured the key, then the key is tested for existing key bindings (see
 * @ref key_binder). This event provides five arguments to the registered
 * callback: a number identifying the main key being pressed, three boolean flags
 * for "Shift", "Ctrl", and "Alt, and finally the human-readable name of the
 * key combination being pressed (e.g., Shift+A).
 * - `OnKeyRepeat`: Similar to `OnKeyDown`, but triggered when a key has been
 * long-pressed and the operating system generated repeat events.
 * - `OnKeyUp`: Similar to `OnKeyDown`, but triggered when a keyboard key is
 * released.
 * - `OnLeave`: Triggered when the mouse pointer leaves the area of the
 * screen occupied by the frame. Note: this only takes into account the
 * position and size of the frame and its title region, but not the space
 * occupied by its children or layered regions. Will not trigger if the
 * frame is hidden, unless the frame was just hidden with the mouse
 * previously inside the frame. Finally, this _will_ trigger whenever
 * the mouse enters another mouse-enabled frame with a higher level/strata,
 * even if the mouse is still technically within this frame's region.
 * - `OnLoad`: Triggered just after the frame is created. This is where
 * you would normally register for events and specific inputs, set up
 * initial states for extra logic, or do localization.
 * - `OnMouseDown`: Triggered when a mouse button is pressed and this frame is
 * the topmost mouse-click-enabled frame under the mouse pointer. Will not
 * trigger if the frame is hidden. This event provides four arguments to
 * the registered callback: a number identifying the mouse button, a string
 * containing the human-readable name of this button (`"LeftButton"`,
 * `"RightButton"`, or `"MiddleButton"`), and the mouse X and Y position.
 * - `OnMouseMove`: Triggered when the mouse moves over this frame, after
 * `OnEnter` and until `OnLeave`. This event provides four argument to
 * the registered callback: the amount of mouse movement in X and Y since the
 * last call to `OnMouseMove` (or since the last position before the mouse
 * entered this frame), and the mouse X and Y position.
 * - `OnMouseUp`: Similar to `OnMouseDown`, but triggered when the mouse button
 * is released.
 * - `OnMouseWheel`: Triggered when the mouse wheel is moved and this frame is
 * the topmost mouse-wheel-enabled frame under the mouse pointer. This event
 * provides three arguments to the registered callback. The first is a number
 * indicating by how many "notches" the wheel has turned in this event. A
 * positive value means the wheel has been moved "away" from the user (this
 * would normally scroll *up* in a document). The other two arguments
 * are the mouse X and Y position.
 * - `OnReceiveDrag`: Triggered when the mouse pointer was previously
 * dragged onto the frame, and when one of the mouse button registered for
 * dragging (see frame::enable_drag) is released. This enables
 * the "drop" in "drag and drop" operations.
 * - `OnShow`: Triggered when region::show is called, or when the frame
 * is shown indirectly (for example if its parent is itself shown). This
 * will only fire if the frame was previously hidden.
 * - `OnSizeChanged`: Triggered whenever the size of the frame changes, either
 * directly or indirectly. Be very careful not to call any function that could
 * change the size of the frame inside this callback, as this would generate
 * an infinite loop.
 * - `OnUpdate`: Triggered on every tick of the game loop. This event provides
 * one argument to the registered callback: a floating point number indicating
 * how much time has passed since the last call to `OnUpdate` (in seconds).
 * For optimal performance, prefer using other events types whenever possible.
 * `OnUpdate` callbacks will be executed over and over again, and can quickly
 * consume a lot of resources if user unreasonably. If you have to use
 * `OnUpdate`, you can mitigate performance problems by artificially reducing
 * the update rate: let the callback function only accumulate the time passed,
 * and wait until enough time has passed (say, half a second) to execute any
 * expensive operation. Then reset the accumulated time, and wait again.
 *
 * Generic events fired natively by lxgui:
 *
 * - `"LUA_ERROR"`: Triggered whenever a callback function or an addon script
 * file generates a Lua error. This event provides one argument to the
 * registered callback: a string containing the error message.
 * - `"ADDON_LOADED"`: Triggered when an addon is fully loaded. This event
 * provides one argument to the registered callback: a string containing the
 * name of the loaded addon.
 * - `"ENTERING_WORLD"`: Triggered once at the start of the program, at the
 * end of the first update tick.
 *
 * __Virtual frames.__ Virtual frames are not displayed on the screen,
 * and technically are not part of the interface. They are only available
 * as "templates" that can be reused by other (virtual or non-virtual)
 * frames. This is useful for defining a few frame templates with a
 * particular style, and then reuse these templates across the interface
 * to ensure a consistent look. When inheriting from a virtual frame,
 * the inheriting frame will copy all the registered callbacks, all the
 * child frames, and all the layered regions of the virtual frame.
 */
class frame : public region {
    using base = region;

public:
    /**
     * \brief Type of the frame child list (internal).
     * \note Constraints on the choice container type:
     *  - must not invalidate iterators on back insertion
     *  - must allow forward iteration
     *  - iterators can be invalidated on removal
     *  - most common use is iteration, not addition or removal
     *  - ordering of elements is irrelevant
     */
    using child_list      = std::list<utils::owner_ptr<frame>>;
    using child_list_view = utils::view::
        adaptor<child_list, utils::view::smart_ptr_dereferencer, utils::view::non_null_filter>;
    using const_child_list_view = utils::view::adaptor<
        const child_list,
        utils::view::smart_ptr_dereferencer,
        utils::view::non_null_filter>;

    /**
     * \brief Type of the region list (internal).
     * \note Constraints on the choice container type:
     *  - must not invalidate iterators on back insertion
     *  - must allow forward iteration
     *  - iterators can be invalidated on removal
     *  - most common use is iteration, not addition or removal
     *  - ordering of elements is irrelevant
     */
    using region_list      = std::list<utils::owner_ptr<layered_region>>;
    using region_list_view = utils::view::
        adaptor<region_list, utils::view::smart_ptr_dereferencer, utils::view::non_null_filter>;
    using const_region_list_view = utils::view::adaptor<
        const region_list,
        utils::view::smart_ptr_dereferencer,
        utils::view::non_null_filter>;

    /// Constructor.
    explicit frame(utils::control_block& block, manager& mgr, const frame_core_attributes& attr);

    /// Destructor.
    ~frame() override;

    /// Renders this region on the current render target.
    void render() const override;

    /**
     * \brief Updates this region's logic.
     * \param delta Time spent since last update
     * \note Triggered callbacks could destroy the frame. If you need
     * to use the frame again after calling this function, use
     * the helper class alive_checker.
     */
    void update(float delta) override;

    /**
     * \brief Prints all relevant information about this region in a string.
     * \param tab The offset to give to all lines
     * \return All relevant information about this region
     */
    std::string serialize(const std::string& tab) const override;

    /**
     * \brief Returns 'true' if this frame can use a script.
     * \param script_name The name of the script
     * \note This method can be overridden if needed.
     */
    virtual bool can_use_script(const std::string& script_name) const;

    /**
     * \brief Copies a region's parameters into this frame (inheritance).
     * \param obj The region to copy
     */
    void copy_from(const region& obj) override;

    /**
     * \brief Creates a new title region for this frame.
     * \note You can get it by calling get_title_region().
     */
    void create_title_region();

    /**
     * \brief Disables a layer.
     * \param layer_id The id of the layer to disable
     */
    void disable_draw_layer(layer layer_id);

    /**
     * \brief Enables a layer.
     * \param layer_id The id of the layer to enable
     */
    void enable_draw_layer(layer layer_id);

    /**
     * \brief Sets if this frame can receive mouse input (click & move).
     * \param is_mouse_enabled 'true' to enable
     */
    void enable_mouse(bool is_mouse_enabled);

    /**
     * \brief Sets if this frame can receive mouse click input.
     * \param is_mouse_enabled 'true' to enable
     */
    void enable_mouse_click(bool is_mouse_enabled);

    /**
     * \brief Sets if this frame can receive mouse move input.
     * \param is_mouse_enabled 'true' to enable
     */
    void enable_mouse_move(bool is_mouse_enabled);

    /**
     * \brief Sets if this frame can receive mouse wheel input.
     * \param is_mouse_wheel_enabled 'true' to enable
     */
    void enable_mouse_wheel(bool is_mouse_wheel_enabled);

    /**
     * \brief Sets if this frame can receive any keyboard input.
     * \param is_keyboard_enabled 'true' to enable
     * \note If enabled, specific keys must be enabled for capture to actually receive keybaord
     * events.
     * \see is_keyboard_enabled()
     * \see enable_key_capture()
     * \see is_key_capture_enabled()
     */
    void enable_keyboard(bool is_keyboard_enabled);

    /**
     * \brief Marks this frame as able to receive keyboard input from a specific key.
     * \param key_name The key to capture
     * \note If the frame captures the key, other frames below it will not be able to receive
     * the input from this key. The format of the input key name is standard English,
     * with modifiers for the "Control" (Ctrl), "Shift", and "Alt" keys. For example,
     * "Ctrl-Shift-C" corresponds to the Ctrl, Shift, and C keys being pressed
     * simultaneously. Keyboard input must be enabled for capture to take place.
     * \see disable_key_capture()
     * \see is_key_capture_enabled()
     * \see enable_keyboard()
     * \see is_keyboard_enabled()
     */
    void enable_key_capture(const std::string& key_name);

    /**
     * \brief Marks this frame as able to receive keyboard input from a specific key.
     * \param key_id The key to capture
     * \note See @ref enable_key_capture(const std::string&) for more information.
     * This overload only allows capturing a single key; for key combinations,
     * please use the overload taking a string.
     * \see disable_key_capture()
     * \see is_key_capture_enabled()
     * \see enable_keyboard()
     * \see is_keyboard_enabled()
     */
    void enable_key_capture(input::key key_id);

    /**
     * \brief Marks this frame as unable to receive keyboard input from a specific key.
     * \param key_name The key for which to disable capture
     * \see enable_key_capture()
     * \see is_key_capture_enabled()
     * \see enable_keyboard()
     * \see is_keyboard_enabled()
     */
    void disable_key_capture(const std::string& key_name);
    /**
     * \brief Marks this frame as unable to receive keyboard input from a specific key.
     * \param key_id The key for which to disable capture
     * \note See @ref disable_key_capture(const std::string&) for more information.
     * This overload only allows capturing a single key; for key combinations,
     * please use the overload taking a string.
     * \see enable_key_capture()
     * \see is_key_capture_enabled()
     * \see enable_keyboard()
     * \see is_keyboard_enabled()
     */
    void disable_key_capture(input::key key_id);

    /**
     * \brief Marks this frame as unable to receive keyboard input from any key.
     * \param key_name The key to capture
     * \see enable_key_capture()
     * \see is_key_capture_enabled()
     * \see enable_keyboard()
     * \see is_keyboard_enabled()
     */
    void disable_key_capture();

    /**
     * \brief Checks if this frame has a script defined.
     * \param script_name The name of the script to check
     * \return 'true' if this script is defined
     */
    bool has_script(const std::string& script_name) const;

    /**
     * \brief Adds a layered_region to this frame's children.
     * \param reg The layered_region to add
     */
    utils::observer_ptr<layered_region> add_region(utils::owner_ptr<layered_region> reg);

    /**
     * \brief Adds a layered_region to this frame's children.
     * \param reg The layered_region to add
     */
    template<
        typename RegionType,
        typename Enable =
            typename std::enable_if<std::is_base_of<gui::layered_region, RegionType>::value>::type>
    utils::observer_ptr<RegionType> add_region(utils::owner_ptr<RegionType> reg) {
        return utils::static_pointer_cast<RegionType>(
            add_region(utils::static_pointer_cast<layered_region>(std::move(reg))));
    }

    /**
     * \brief Removes a layered_region from this frame's children.
     * \param reg The layered_region to remove
     * \return A unique_ptr to the region, ignore it to destroy the region.
     */
    utils::owner_ptr<layered_region> remove_region(const utils::observer_ptr<layered_region>& reg);

    /**
     * \brief Creates a new region as child of this frame.
     * \param layer_id The layer on which to create the region
     * \param attr The core attributes of the region (parent will be ignored)
     * \return The created region.
     * \note You don't have the responsibility to delete this region.
     * It will be done automatically when its parent is deleted.
     * \note This function takes care of the basic initializing:
     * you can directly use the created region.
     */
    utils::observer_ptr<layered_region>
    create_layered_region(layer layer_id, region_core_attributes attr);

    /**
     * \brief Creates a new region as child of this frame.
     * \param layer_id The layer on which to create the region
     * \param attr The core attributes of the region (object_type and parent will be ignored)
     * \return The created region.
     * \note You don't have the responsibility to delete this region.
     * It will be done automatically when its parent is deleted.
     * \note This function takes care of the basic initializing:
     * you can directly use the created region.
     */
    template<
        typename RegionType,
        typename Enable =
            typename std::enable_if<std::is_base_of<gui::layered_region, RegionType>::value>::type>
    utils::observer_ptr<RegionType>
    create_layered_region(layer layer_id, region_core_attributes attr) {
        attr.object_type = RegionType::class_name;

        return utils::static_pointer_cast<RegionType>(
            create_layered_region(layer_id, std::move(attr)));
    }

    /**
     * \brief Creates a new region as child of this frame.
     * \param layer_id The layer on which to create the region
     * \param name The name of the region
     * \return The created region.
     * \note You don't have the responsibility to delete this region.
     * It will be done automatically when its parent is deleted.
     * \note This function takes care of the basic initializing:
     * you can directly use the created region.
     */
    template<
        typename RegionType,
        typename Enable =
            typename std::enable_if<std::is_base_of<gui::layered_region, RegionType>::value>::type>
    utils::observer_ptr<RegionType> create_layered_region(layer layer_id, const std::string& name) {
        region_core_attributes attr;
        attr.name        = name;
        attr.object_type = RegionType::class_name;

        return utils::static_pointer_cast<RegionType>(
            create_layered_region(layer_id, std::move(attr)));
    }

    /**
     * \brief Creates a new frame as child of this frame.
     * \param attr The core attributes of the frame (parent will be ignored)
     * \return The created frame.
     * \note You don't have the responsibility to delete this frame.
     * It will be done automatically when its parent is deleted.
     * \note This function takes care of the basic initializing:
     * you can directly use the created frame. However, you still need to call
     * notify_loaded() when you are done with any extra initialization you require on
     * this frame. If you do not, the frame's OnLoad callback will not fire.
     */
    utils::observer_ptr<frame> create_child(frame_core_attributes attr);

    /**
     * \brief Creates a new frame as child of this frame.
     * \param attr The core attributes of the frame (object_type and parent will be ignored)
     * \return The created frame.
     * \note You don't have the responsibility to delete this frame.
     * It will be done automatically when its parent is deleted.
     * \note This function takes care of the basic initializing:
     * you can directly use the created frame. However, you still need to call
     * notify_loaded() when you are done with any extra initialization you require on this
     * frame. If you do not, the frame's OnLoad callback will not fire.
     */
    template<
        typename FrameType,
        typename Enable =
            typename std::enable_if<std::is_base_of<gui::frame, FrameType>::value>::type>
    utils::observer_ptr<FrameType> create_child(frame_core_attributes attr) {
        attr.object_type = FrameType::class_name;

        return utils::static_pointer_cast<FrameType>(create_child(std::move(attr)));
    }

    /**
     * \brief Creates a new frame as child of this frame.
     * \param name The name of the frame
     * \return The created frame.
     * \note You don't have the responsibility to delete this frame.
     * It will be done automatically when its parent is deleted.
     * \note This function takes care of the basic initializing:
     * you can directly use the created frame. However, you still need to call
     * notify_loaded() when you are done with any extra initialization you require on this
     * frame. If you do not, the frame's OnLoad callback will not fire.
     */
    template<
        typename FrameType,
        typename Enable =
            typename std::enable_if<std::is_base_of<gui::frame, FrameType>::value>::type>
    utils::observer_ptr<FrameType> create_child(const std::string& name) {
        frame_core_attributes attr;
        attr.name        = name;
        attr.object_type = FrameType::class_name;

        return utils::static_pointer_cast<FrameType>(create_child(std::move(attr)));
    }

    /**
     * \brief Adds a frame to this frame's children.
     * \param child The frame to add
     */
    utils::observer_ptr<frame> add_child(utils::owner_ptr<frame> child);

    /**
     * \brief Adds a frame to this frame's children.
     * \param child The frame to add
     */
    template<
        typename FrameType,
        typename Enable =
            typename std::enable_if<std::is_base_of<gui::frame, FrameType>::value>::type>
    utils::observer_ptr<FrameType> add_child(utils::owner_ptr<FrameType> child) {
        return utils::static_pointer_cast<FrameType>(
            add_child(utils::static_pointer_cast<frame>(std::move(child))));
    }

    /**
     * \brief Removes a frame from this frame's children.
     * \param child The frame to remove
        \return A unique_ptr to the child, ignore it to destroy the child.
    */
    utils::owner_ptr<frame> remove_child(const utils::observer_ptr<frame>& child);

    /**
     * \brief Returns the child list.
     * \return The child list
     */
    child_list_view get_children();

    /**
     * \brief Returns the child list.
     * \return The child list
     */
    const_child_list_view get_children() const;

    /**
     * \brief Returns one of this frame's children.
     * \param name The name of the child
     * \return One of this frame's children
     * \note The provided name can either be the full name or the relative name
     * (i.e. without the "$parent" in front). This function first looks
     * for matches on the full name, then if no child is found, on the
     * relative name.
     */
    utils::observer_ptr<const frame> get_child(const std::string& name) const;

    /**
     * \brief Returns one of this frame's children.
     * \param name The name of the child
     * \return One of this frame's children
     * \note The provided name can either be the full name or the relative name
     * (i.e. without the "$parent" in front). This function first looks
     * for matches on the full name, then if no child is found, on the
     * relative name.
     */
    utils::observer_ptr<frame> get_child(const std::string& name) {
        return utils::const_pointer_cast<frame>(const_cast<const frame*>(this)->get_child(name));
    }

    /**
     * \brief Returns one of this frame's children.
     * \param name The name of the child
     * \return One of this frame's children
     * \note The provided name can either be the full name or the relative name
     * (i.e. without the "$parent" in front). This function first looks
     * for matches on the full name, then if no child is found, on the
     * relative name.
     */
    template<
        typename FrameType,
        typename Enable =
            typename std::enable_if<std::is_base_of<gui::frame, FrameType>::value>::type>
    utils::observer_ptr<const FrameType> get_child(const std::string& name) const {
        return down_cast<FrameType>(get_child(name));
    }

    /**
     * \brief Returns one of this frame's children.
     * \param name The name of the child
     * \return One of this frame's children
     * \note The provided name can either be the full name or the relative name
     * (i.e. without the "$parent" in front). This function first looks
     * for matches on the full name, then if no child is found, on the
     * relative name.
     */
    template<
        typename FrameType,
        typename Enable =
            typename std::enable_if<std::is_base_of<gui::frame, FrameType>::value>::type>
    utils::observer_ptr<FrameType> get_child(const std::string& name) {
        return down_cast<FrameType>(get_child(name));
    }

    /**
     * \brief Returns the region list.
     * \return The region list
     */
    region_list_view get_regions();

    /**
     * \brief Returns the region list.
     * \return The region list
     */
    const_region_list_view get_regions() const;

    /**
     * \brief Returns one of this frame's region.
     * \param name The name of the region
     * \return One of this frame's region
     * \note The provided name can either be the full name or the relative name
     * (i.e. without the "$parent" in front). This function first looks
     * for matches on the full name, then if no region is found, on the
     * relative name.
     */
    utils::observer_ptr<const layered_region> get_region(const std::string& name) const;

    /**
     * \brief Returns one of this frame's region.
     * \param name The name of the region
     * \return One of this frame's region
     * \note The provided name can either be the full name or the relative name
     * (i.e. without the "$parent" in front). This function first looks
     * for matches on the full name, then if no region is found, on the
     * relative name.
     */
    utils::observer_ptr<layered_region> get_region(const std::string& name) {
        return utils::const_pointer_cast<layered_region>(
            const_cast<const frame*>(this)->get_region(name));
    }

    /**
     * \brief Returns one of this frame's region.
     * \param name The name of the region
     * \return One of this frame's region
     * \note The provided name can either be the full name or the relative name
     * (i.e. without the "$parent" in front). This function first looks
     * for matches on the full name, then if no region is found, on the
     * relative name.
     */
    template<
        typename RegionType,
        typename Enable =
            typename std::enable_if<std::is_base_of<gui::layered_region, RegionType>::value>::type>
    utils::observer_ptr<RegionType> get_region(const std::string& name) {
        return down_cast<RegionType>(get_region(name));
    }

    /**
     * \brief Calculates effective alpha.
     * \return Effective alpha (alpha*parent->alpha)
     */
    float get_effective_alpha() const;

    /**
     * \brief Calculates effective scale.
     * \return Effective scale (scale*parent->scale)
     */
    float get_effective_scale() const;

    /**
     * \brief Returns this frame's level.
     * \return This frame's level
     */
    int get_level() const;

    /**
     * \brief Returns this frame's strata.
     * \return This frame's strata
     */
    frame_strata get_frame_strata() const;

    /**
     * \brief Returns this frame's effective strata.
     * \return This frame's strata, or its parent's effective strata if frame_strata::parent.
     */
    frame_strata get_effective_frame_strata() const;

    /**
     * \brief Returns this frame's top-level parent.
     * \return This frame's top-level parent
     */
    utils::observer_ptr<const frame> get_top_level_parent() const;

    /**
     * \brief Returns this frame's top-level parent.
     * \return This frame's top-level parent
     */
    utils::observer_ptr<frame> get_top_level_parent() {
        return utils::const_pointer_cast<frame>(
            const_cast<const frame*>(this)->get_top_level_parent());
    }

    /**
     * \brief Returns this frame's backdrop.
     * \return This frame's backdrop
     */
    const backdrop* get_backdrop() const;

    /**
     * \brief Returns this frame's backdrop.
     * \return This frame's backdrop
     */
    backdrop* get_backdrop();

    /**
     * \brief Returns this frame's backdrop, creating it if needed
     * \return This frame's backdrop
     */
    backdrop& get_or_create_backdrop();

    /**
     * \brief Returns this frame's type.
     * \return This frame's type (Frame, Slider, ...)
     */
    const std::string& get_frame_type() const;

    /**
     * \brief Returns this frame's absolute hit rect insets.
     * \return This frame's absolute hit rect insets
     */
    const bounds2f& get_abs_hit_rect_insets() const;

    /**
     * \brief Returns this frame's relative hit rect insets.
     * \return This frame's relative hit rect insets
     */
    const bounds2f& get_rel_hit_rect_insets() const;

    /**
     * \brief Returns this frame's max dimensions.
     * \return This frame's max dimensions
     */
    vector2f get_max_dimensions() const;

    /**
     * \brief Returns this frame's min dimensions.
     * \return This frame's min dimensions
     */
    vector2f get_min_dimensions() const;

    /**
     * \brief Returns the number of children of this frame.
     * \return The number of children of this frame
     * \note If only an approximate number is acceptable, use get_rough_num_children(),
     * which is faster.
     */
    std::size_t get_num_children() const;

    /**
     * \brief Returns the approximate number of children of this frame.
     * \return The approximate number of children of this frame
     * \note The returned number is an *upper bound* on the actual number of children.
     * This can be used to reserve enough space for memory allocations.
     * If the exact number of children is required, use get_num_children().
     */
    std::size_t get_rough_num_children() const;

    /**
     * \brief Returns the number of regions of this frame.
     * \return The number of regions of this frame
     * \note If only an approximate number is acceptable, use get_rough_num_regions(),
     * which is faster.
     */
    std::size_t get_num_regions() const;

    /**
     * \brief Returns the approximate number of regions of this frame.
     * \return The approximate number of regions of this frame
     * \note The returned number is an *upper bound* on the actual number of regions.
     * This can be used to reserve enough space for memory allocations.
     * If the exact number of regions is required, use get_num_regions().
     */
    std::size_t get_rough_num_regions() const;

    /**
     * \brief Returns this frame's scale.
     * \return This frame's scale
     * \note If you want it's true scale on the screen,
     * use get_effective_scale().
     */
    float get_scale() const;

    /// Returns this frame's title region.
    utils::observer_ptr<const region> get_title_region() const {
        return title_region_;
    }

    /// Returns this frame's title region.
    utils::observer_ptr<region> get_title_region() {
        return title_region_;
    }

    /**
     * \brief Checks if this frame is clamped to screen.
     * \return 'true' if this frame is clamped to screen
     */
    bool is_clamped_to_screen() const;

    /**
     * \brief Checks if the provided coordinates are inside this frame.
     * \param position The coordinates to test
     * \return 'true' if the provided coordinates are inside this frame or its title region
     */
    bool is_in_region(const vector2f& position) const override;

    /**
     * \brief Find the topmost frame matching the provided predicate.
     * \param predicate A function returning 'true' if the frame can be selected
     * \return The topmost frame, if any, and nullptr otherwise.
     * \note For most frames, this can either return 'this' or 'nullptr'. For
     * frames responsible for rendering other frames (such as @ref scroll_frame),
     * this can return other frames.
     */
    virtual utils::observer_ptr<const frame>
    find_topmost_frame(const std::function<bool(const frame&)>& predicate) const;

    /**
     * \brief Find the topmost frame matching the provided predicate.
     * \param predicate A function returning 'true' if the frame can be selected
     * \return The topmost frame, if any, and nullptr otherwise.
     * \note For most frames, this can either return 'this' or 'nullptr'. For
     * frames responsible for rendering other frames (such as @ref scroll_frame),
     * this can return other frames.
     */
    utils::observer_ptr<frame>
    find_topmost_frame(const std::function<bool(const frame&)>& predicate) {
        return utils::const_pointer_cast<frame>(
            const_cast<const frame*>(this)->find_topmost_frame(predicate));
    }

    /**
     * \brief Checks if this frame can receive mouse movement input.
     * \return 'true' if this frame can receive mouse movement input
     */
    bool is_mouse_move_enabled() const;

    /**
     * \brief Checks if this frame can receive mouse click input.
     * \return 'true' if this frame can receive mouse click input
     */
    bool is_mouse_click_enabled() const;

    /**
     * \brief Checks if this frame can receive mouse wheel input.
     * \return 'true' if this frame can receive mouse wheel input
     */
    bool is_mouse_wheel_enabled() const;

    /**
     * \brief Checks if this frame is registered for drag events with the provided mouse button.
     * \param button_name The name of the mouse button to check
     * \return 'true' if this frame is registered for drag events with the provided mouse button
     */
    bool is_drag_enabled(const std::string& button_name) const;

    /**
     * \brief Checks if this frame can receive keyboard input from a specific key.
     * \param key_name The key to check
     * \return 'true' if this frame can receive keyboard input from this key
     * \see enable_key_capture()
     * \see enable_keyboard()
     * \see is_keyboard_enabled()
     */
    bool is_key_capture_enabled(const std::string& key_name) const;

    /**
     * \brief Checks if this frame can receive any keyboard input.
     * \return 'true' if this frame can receive any keyboard input
     * \see enable_key_capture()
     * \see is_key_capture_enabled()
     * \see enable_keyboard()
     */
    bool is_keyboard_enabled() const;

    /**
     * \brief Checks if this frame can be moved.
     * \return 'true' if this frame can be moved
     */
    bool is_movable() const;

    /**
     * \brief Checks if this frame can be resized.
     * \return 'true' if this frame can be resized
     */
    bool is_resizable() const;

    /**
     * \brief Checks if this frame is at top level.
     * \return 'true' if this frame is at top level
     */
    bool is_top_level() const;

    /**
     * \brief Checks if this frame has been moved by the user.
     * \return 'true' if this frame has been moved by the user
     */
    bool is_user_placed() const;

    /**
     * \brief Returns the "adjusted" script name: "OnEvent" becomes "on_event"
     * \param script_name The CamelCase name of the script
     * \return the snake_case name of the script
     */
    static std::string get_adjusted_script_name(const std::string& script_name);

    /**
     * \brief Adds an additional handler script to this frame (executed after existing scripts).
     * \param script_name The name of the script (e.g., "OnEvent")
     * \param content The content of the script, as Lua code
     * \param info The location where this script has been defined
     * \return A connection object, to disable the script if needed.
     *
     * \note The script_info parameter is used only for displaying error messages.
     * This function is meant to be used by the layout file parser. If you want to
     * manually define your own script handlers, prefer the other overloads.
     */
    utils::connection add_script(
        const std::string& script_name, std::string content, script_info info = script_info{}) {
        return define_script_(script_name, content, true, info);
    }

    /**
     * \brief Adds an additional handler script to this frame (executed after existing scripts).
     * \param script_name The name of the script (e.g., "OnEvent")
     * \param handler The handler of the script, as a Lua function
     * \param info The location where this script has been defined
     * \return A connection object, to disable the script if needed.
     *
     * \note This defines a Lua function to be called for the event specified in script_name.
     * This provides more flexibility compared to using C++ function, but also has a
     * larger overhead. If performance is a concern, prefer the other overload taking a
     * C++ function instead.
     */
    utils::connection add_script(
        const std::string&      script_name,
        sol::protected_function handler,
        script_info             info = script_info{}) {
        return define_script_(script_name, std::move(handler), true, info);
    }

    /**
     * \brief Adds an additional handler script to this frame (executed after existing scripts).
     * \param script_name The name of the script (e.g., "OnEvent")
     * \param handler The handler of the script, as a C++ function of signature \ref script_signature
     * \param info The location where this script has been defined
     * \return A connection object, to disable the script if needed.
     *
     * \note This defines a C++ function to be called for the event specified in \p script_name.
     * This provides the best performance, but lacks direct access to the Lua
     * environment. If this is required, prefer the other overload taking a Lua function
     * instead.
     */
    utils::connection add_script(
        const std::string& script_name, script_function handler, script_info info = script_info{}) {
        return define_script_(script_name, std::move(handler), true, info);
    }

    /**
     * \brief Adds an additional handler script to this frame (executed after existing scripts).
     * \param script_name The name of the script (e.g., "OnEvent")
     * \param handler The handler of the script, as a C++ function (see below for expected signature)
     * \param info The location where this script has been defined
     * \return A connection object, to disable the script if needed.
     *
     * \note This defines a C++ function to be called for the event specified in \p script_name.
     * This provides the best performance, but lacks direct access to the Lua
     * environment. If this is required, prefer the other overload taking a Lua function
     * instead.
     *
     * \note This overload enables taking handler scripts with a `self` parameter of type other than
     * \ref frame, for example:
     * \begin_code{cpp}
     * add_script([](button& self, const event_data& data) { ... });
     * \end_code
     * For maximum safety, by default this is done using a `dynamic_cast`, so that incorrect types
     * will be reported. However this has a cost; if you are sure of the type and want to bypass
     * this cost, just supply the `self` type as the first template argument to this function:
     * \begin_code{cpp}
     * add_script<button>([](button& self, const event_data& data) { ... });
     * \end_code
     */
    template<typename DerivedType = void, typename Function>
    utils::connection add_script(
        const std::string& script_name, Function&& handler, script_info info = script_info{}) {

        return add_script(
            script_name,
            script_function(
                [handler = std::move(handler)](frame& self, const event_data& data) mutable {
                    constexpr bool use_automatic_cast = std::is_same_v<DerivedType, void>;

                    using derived_type = std::decay_t<std::conditional_t<
                        use_automatic_cast, utils::first_function_argument<Function>, DerivedType>>;

                    constexpr bool use_no_cast = std::is_same_v<derived_type, frame>;

                    if constexpr (use_no_cast) {
                        handler(self, data);
                    } else if constexpr (use_automatic_cast) {
                        handler(down_cast<derived_type>(self), data);
                    } else {
                        handler(static_cast<derived_type&>(self), data);
                    }
                }),
            info);
    }

    /**
     * \brief Sets a new handler script for this frame (replacing existing scripts).
     * \param script_name The name of the script (e.g., "OnEvent")
     * \param content The content of the script, as Lua code
     * \param info The location where this script has been defined
     * \return A connection object, to disable the script if needed.
     *
     * \note The script_info parameter is used only for displaying error messages.
     * This function is meant to be used by the layout file parser. If you want to
     * manually define your own script handlers, prefer the other overloads.
     */
    utils::connection set_script(
        const std::string& script_name, std::string content, script_info info = script_info{}) {
        return define_script_(script_name, content, false, info);
    }

    /**
     * \brief Sets a new handler script for this frame (replacing existing scripts).
     * \param script_name The name of the script (e.g., "OnEvent")
     * \param handler The handler of the script, as a Lua function
     * \param info The location where this script has been defined
     * \return A connection object, to disable the script if needed.
     *
     * \note This defines a Lua function to be called for the event specified in script_name.
     * This provides more flexibility compared to using C++ function, but also has a
     * larger overhead. If performance is a concern, prefer the other overload taking a
     * C++ function instead.
     */
    utils::connection set_script(
        const std::string&      script_name,
        sol::protected_function handler,
        script_info             info = script_info{}) {
        return define_script_(script_name, std::move(handler), false, info);
    }

    /**
     * \brief Sets a new handler script for this frame (replacing existing scripts).
     * \param script_name The name of the script (e.g., "OnEvent")
     * \param handler The handler of the script, as a C++ function of signature \ref script_signature
     * \param info The location where this script has been defined
     * \return A connection object, to disable the script if needed.
     *
     * \note This defines a C++ function to be called for the event specified in script_name.
     * This provides the best performance, but lacks direct access to the Lua
     * environment. If this is required, prefer the other overload taking a Lua function
     * instead.
     */
    utils::connection set_script(
        const std::string& script_name, script_function handler, script_info info = script_info{}) {
        return define_script_(script_name, std::move(handler), false, info);
    }

    /**
     * \brief Sets a new handler script for this frame (replacing existing scripts).
     * \param script_name The name of the script (e.g., "OnEvent")
     * \param handler The handler of the script, as a C++ function of signature \ref script_signature
     * \param info The location where this script has been defined
     * \return A connection object, to disable the script if needed.
     *
     * \note This defines a C++ function to be called for the event specified in script_name.
     * This provides the best performance, but lacks direct access to the Lua
     * environment. If this is required, prefer the other overload taking a Lua function
     * instead.
     *
     * \note This overload enables taking handler scripts with a `self` parameter of type other than
     * \ref frame, for example:
     * \begin_code{cpp}
     * add_script([](button& self, const event_data& data) { ... });
     * \end_code
     * For maximum safety, by default this is done using a `dynamic_cast`, so that incorrect types
     * will be reported. However this has a cost; if you are sure of the type and want to bypass
     * this cost, just supply the `self` type as the first template argument to this function:
     * \begin_code{cpp}
     * add_script<button>([](button& self, const event_data& data) { ... });
     * \end_code
     */
    template<typename DerivedType = void, typename Function>
    utils::connection set_script(
        const std::string& script_name, Function&& handler, script_info info = script_info{}) {

        return set_script(
            script_name,
            script_function(
                [handler = std::move(handler)](frame& self, const event_data& data) mutable {
                    constexpr bool use_automatic_cast = std::is_same_v<DerivedType, void>;

                    using derived_type = std::decay_t<std::conditional_t<
                        use_automatic_cast, utils::first_function_argument<Function>, DerivedType>>;

                    constexpr bool use_no_cast = std::is_same_v<derived_type, frame>;

                    if constexpr (use_no_cast) {
                        handler(self, data);
                    } else if constexpr (use_automatic_cast) {
                        handler(down_cast<derived_type>(self), data);
                    } else {
                        handler(static_cast<derived_type&>(self), data);
                    }
                }),
            info);
    }

    /**
     * \brief Return a view into this frame's handler scripts, registered for the given event.
     * \param script_name The name of the script (e.g., "OnEvent")
     * \return An iterable view into the frame's handlers.
     */
    script_list_view get_script(const std::string& script_name) const;

    /**
     * \brief Removes a script from this frame.
     * \param script_name The name of the script (e.g., "OnEvent")
     * \note This removes all handler scripts registered to this event, including the ones
     * inherited from templates.
     */
    void remove_script(const std::string& script_name);

    /**
     * \brief Calls a script.
     * \param script_name The name of the script (e.g., "OnEvent")
     * \param data Stores scripts arguments
     * \note Triggered callbacks could destroy the frame. If you need
     * to use the frame again after calling this function, use
     * the helper class alive_checker.
     */
    virtual void fire_script(const std::string& script_name, const event_data& data = event_data{});

    /**
     * \brief Tells this frame to react to a certain event.
     * \param event_name The name of the event
     */
    void register_event(const std::string& event_name);

    /**
     * \brief Tells the frame not to react to a certain event.
     * \param event_name The name of the event
     */
    void unregister_event(const std::string& event_name);

    /**
     * \brief Tells this frame to react to mouse drag.
     * \param button_name The mouse button to react to
     */
    void enable_drag(const std::string& button_name);

    /**
     * \brief Tells this frame to react to mouse drag.
     * \param button_id The mouse button to react to
     */
    void enable_drag(input::mouse_button button_id);

    /**
     * \brief Tells this frame to not react to mouse drag.
     * \param button_name The mouse button to not react to
     */
    void disable_drag(const std::string& button_name);

    /**
     * \brief Tells this frame to not react to mouse drag.
     * \param button_id The mouse button to not react to
     */
    void disable_drag(input::mouse_button button_id);

    /**
     * \brief Tells this frame to not react to mouse drag from any mouse button.
     */
    void disable_drag();

    /**
     * \brief Sets if this frame is clamped to screen.
     * \param is_clamped_to_screen 'true' if this frame is clamped to screen
     * \note If 'true', the frame can't go out of the screen.
     */
    void set_clamped_to_screen(bool is_clamped_to_screen);

    /**
     * \brief Sets this frame's strata.
     * \param strata_id The new strata
     */
    void set_frame_strata(frame_strata strata_id);

    /**
     * \brief Sets this frames' backdrop.
     * \param bdrop The new backdrop
     */
    void set_backdrop(std::unique_ptr<backdrop> bdrop);

    /**
     * \brief Sets this frame's absolute hit rect insets.
     * \param insets Offsets
     * \note This is the zone on which you can click.
     */
    void set_abs_hit_rect_insets(const bounds2f& insets);

    /**
     * \brief Sets this frame's relative hit rect insets.
     * \param insets Offsets
     * \note This is the zone on which you can click.
     */
    void set_rel_hit_rect_insets(const bounds2f& insets);

    /**
     * \brief Sets this frame's level.
     * \param level_id The new level
     */
    void set_level(int level_id);

    /**
     * \brief Sets this frame's maximum size.
     * \param max The maximum dimensions of this frame
     */
    void set_max_dimensions(const vector2f& max);

    /**
     * \brief Sets this frame's minimum size.
     * \param min Minimum dimensions of this frame
     */
    void set_min_dimensions(const vector2f& min);

    /**
     * \brief Sets this frame's maximum height.
     * \param max_height The maximum height this frame can have
     */
    void set_max_height(float max_height);

    /**
     * \brief Sets this frame's maximum width.
     * \param max_width The maximum width this frame can have
     */
    void set_max_width(float max_width);

    /**
     * \brief Sets this frame's minimum height.
     * \param min_height The minimum height this frame can have
     */
    void set_min_height(float min_height);

    /**
     * \brief Sets this frame's minimum width.
     * \param min_width The minimum width this frame can have
     */
    void set_min_width(float min_width);

    /**
     * \brief Sets if this frame can be moved by the user.
     * \param is_movable 'true' to allow the user to move this frame
     */
    void set_movable(bool is_movable);

    /**
     * \brief Removes this region from its parent and return an owning pointer.
     * \return An owning pointer to this region
     */
    utils::owner_ptr<region> release_from_parent() override;

    /**
     * \brief Sets if this frame can be resized by the user.
     * \param is_resizable 'true' to allow the user to resize this frame
     */
    void set_resizable(bool is_resizable);

    /**
     * \brief Sets this frame's scale.
     * \param scale The new scale
     */
    void set_scale(float scale);

    /**
     * \brief Sets if this frame is at top level.
     * \param is_top_level 'true' to put the frame at top level
     * \note A top-level frame will be raised to the foreground if it or
     * any of its children are clicked. This should typically be
     * set to 'true' for any "dialog" or "window" frame, which
     * can be moved around, and not for "element" frames (buttons, etc.).
     */
    void set_top_level(bool is_top_level);

    /**
     * \brief Increases this frame's level so it's the highest of the strata.
     * \note All its children are raised of the same amount.
     * \note Only works for top level frames.
     */
    void raise();

    /**
     * \brief Sets if this frame has been moved by the user.
     * \param is_user_placed 'true' if this frame has been moved by the user
     */
    void set_user_placed(bool is_user_placed);

    /// Starts moving this frame with the mouse.
    void start_moving();

    /// ends moving this frame.
    void stop_moving();

    /**
     * \brief Starts resizing this frame with the mouse.
     * \param p The corner to move
     */
    void start_sizing(const point& p);

    /// ends resizing this frame.
    void stop_sizing();

    /**
     * \brief shows this region.
     * \note Its parent must be shown for it to appear on
     * the screen.
     */
    void show() override;

    /**
     * \brief hides this region.
     * \note All its children won't be visible on the screen
     * anymore, even if they are still marked as shown.
     */
    void hide() override;

    /**
     * \brief Enables automatic focus when this frame is shown or raised.
     * \param enable 'true' to enable auto focus
     */
    void enable_auto_focus(bool enable);

    /**
     * \brief Checks if automatic focus is enabled.
     * \return 'true' if automatic focus is enabled
     */
    bool is_auto_focus_enabled() const;

    /**
     * \brief Asks for focus for this frame.
     * \param focus 'true' to ask for focus, 'false' to release it
     * \note Focus can be lost if another frame asks for focus later.
     * The focus will be restored automatically when that other frame
     * releases focus, or it can be requested again by calling set_focus(true).
     */
    void set_focus(bool focus);

    /**
     * \brief Check if this frame currently has focus.
     * \return 'true' if the frame has focus, 'false' otherwise
     */
    bool has_focus() const;

    /**
     * \brief Flags this object as rendered by another object.
     * \param rdr The object that will take care of rendering this region
     * \note By default, objects are rendered by the gui::manager.
     * \note The renderer also takes care of providing inputs.
     * \note If the renderer is set to nullptr, the frame will inherit the renderer of its
     * parent. If the frame has no parent, this will default to the gui::manager.
     */
    void set_frame_renderer(utils::observer_ptr<frame_renderer> rdr);

    /**
     * \brief Returns the renderer of this object, nullptr if none.
     * \return The renderer of this object, nullptr if none
     * \note For more information, see @ref set_frame_renderer().
     */
    utils::observer_ptr<const frame_renderer> get_frame_renderer() const {
        return frame_renderer_;
    }

    /**
     * \brief Returns the renderer of this object, nullptr if none.
     * \return The renderer of this object, nullptr if none
     * \note For more information, see @ref set_frame_renderer().
     */
    const utils::observer_ptr<frame_renderer>& get_frame_renderer() {
        return frame_renderer_;
    }

    /**
     * \brief Returns the renderer of this object or its parents, nullptr if none.
     * \return The renderer of this object or its parents, nullptr if none
     * \note For more information, see @ref set_frame_renderer().
     */
    utils::observer_ptr<const frame_renderer> get_top_level_frame_renderer() const final;

    /**
     * \brief Returns the renderer of this object or its parents, nullptr if none.
     * \return The renderer of this object or its parents, nullptr if none
     * \note For more information, see @ref set_frame_renderer().
     */
    utils::observer_ptr<frame_renderer> get_top_level_frame_renderer() {
        return utils::const_pointer_cast<frame_renderer>(
            const_cast<const frame*>(this)->get_top_level_frame_renderer());
    }

    /**
     * \brief Notifies the renderer of this region that it needs to be redrawn.
     * \note Automatically called by any shape changing function.
     */
    void notify_renderer_need_redraw() override;

    /**
     * \brief Changes this region's absolute dimensions (in pixels).
     * \param dimensions The new dimensions
     */
    void set_dimensions(const vector2f& dimensions) override;

    /**
     * \brief Changes this region's absolute width (in pixels).
     * \param abs_width The new width
     */
    void set_width(float abs_width) override;

    /**
     * \brief Changes this region's absolute height (in pixels).
     * \param abs_height The new height
     */
    void set_height(float abs_height) override;

    /**
     * \brief Tells this frame it is being hovered by the mouse.
     * \param mouse_in_frame 'true' if the mouse is above this frame
     * \param mouse_pos The mouse coordinates in pixels
     * \note Always use the mouse position set by this function and
     * not the one returned by the input_manager, because there
     * can be an offset applied (for example with scroll_frame).
     */
    virtual void notify_mouse_in_frame(bool mouse_in_frame, const vector2f& mouse_pos);

    /**
     * \brief Notifies this region that it is now visible on screen.
     * \note Automatically called by show()/hide().
     */
    void notify_visible() override;

    /**
     * \brief Notifies this region that it is no longer visible on screen.
     * \note Automatically called by show()/hide().
     */
    void notify_invisible() override;

    /**
     * \brief Notifies this frame that it has received or lost focus.
     * \param focus 'true' if focus is received, 'false' if lost
     */
    virtual void notify_focus(bool focus);

    /**
     * \brief Notifies this region that it has been fully loaded.
     * \note Calls the "OnLoad" script.
     */
    void notify_loaded() override;

    /**
     * \brief Tells this frame to rebuild its layer list.
     * \note Automatically called by add_region(), remove_region(), and
     * layered_region::set_draw_layer().
     */
    void notify_layers_need_update();

    /// Tells this region that the global interface scaling factor has changed.
    void notify_scaling_factor_updated() override;

    /**
     * \brief Parses data from a layout_node.
     * \param node The layout node
     * \note Derived classes must override parse_all_nodes_before_children_() if
     * they need to parse additional blocks, and parse_attributes_() if they
     * need to parse additional attributes.
     */
    void parse_layout(const layout_node& node) final;

    /// Registers this region class to the provided Lua state
    static void register_on_lua(sol::state& lua);

    static constexpr const char* class_name = "Frame";

protected:
    // Layout parsing
    void         parse_attributes_(const layout_node& node) override;
    virtual void parse_all_nodes_before_children_(const layout_node& node);
    virtual void parse_resize_bounds_node_(const layout_node& node);
    virtual void parse_title_region_node_(const layout_node& node);
    virtual void parse_backdrop_node_(const layout_node& node);
    virtual void parse_hit_rect_insets_node_(const layout_node& node);
    virtual void parse_layers_node_(const layout_node& node);
    virtual void parse_frames_node_(const layout_node& node);
    virtual void parse_scripts_node_(const layout_node& node);

    utils::observer_ptr<layered_region>
    parse_region_(const layout_node& node, const std::string& layer_name, const std::string& type);

    utils::observer_ptr<frame> parse_child_(const layout_node& node, const std::string& type);

    void check_position_();

    void add_level_(int amount);

    void notify_frame_strata_changed_(frame_strata old_strata_id, frame_strata new_strata_id);
    void propagate_renderer_(bool rendered);

    void update_borders_() override;

    /**
     * \brief Changes this region's parent.
     * \param parent The new parent
     * \note Default is nullptr.
     */
    void set_parent_(utils::observer_ptr<frame> parent) override;

    utils::connection define_script_(
        const std::string& script_name,
        const std::string& content,
        bool               append,
        const script_info& info);

    utils::connection define_script_(
        const std::string&      script_name,
        sol::protected_function handler,
        bool                    append,
        const script_info&      info);

    utils::connection define_script_(
        const std::string& script_name,
        script_function    handler,
        bool               append,
        const script_info& info);

    void on_event_(std::string_view event_name, const event_data& event);

    child_list  child_list_;
    region_list region_list_;

    static constexpr std::size_t num_layers = static_cast<std::size_t>(layer::enum_size);

    std::array<layer_container, num_layers> layer_list_;

    std::unordered_map<std::string, script_signal> signal_list_;
    event_receiver                                 event_receiver_;

    std::set<std::string> reg_drag_list_;
    std::set<std::string> reg_key_list_;

    int          level_        = 0;
    frame_strata strata_       = frame_strata::parent;
    bool         is_top_level_ = false;

    utils::observer_ptr<frame_renderer> frame_renderer_ = nullptr;

    std::unique_ptr<backdrop> backdrop_;

    bool is_mouse_click_enabled_ = false;
    bool is_mouse_move_enabled_  = false;
    bool is_mouse_wheel_enabled_ = false;
    bool is_keyboard_enabled_    = false;
    bool is_movable_             = false;
    bool is_clamped_to_screen_   = false;
    bool is_resizable_           = false;
    bool is_user_placed_         = false;

    bool build_layer_list_flag_ = false;

    bounds2f abs_hit_rect_inset_list_ = bounds2f::zero;
    bounds2f rel_hit_rect_inset_list_ = bounds2f::zero;

    float min_width_  = 0.0f;
    float max_width_  = std::numeric_limits<float>::infinity();
    float min_height_ = 0.0f;
    float max_height_ = std::numeric_limits<float>::infinity();

    vector2f old_size_;

    float scale_ = 1.0f;

    bool is_mouse_in_frame_ = false;

    utils::owner_ptr<region> title_region_ = nullptr;

    bool is_focused_    = false;
    bool is_auto_focus_ = false;
};

} // namespace lxgui::gui

#endif
