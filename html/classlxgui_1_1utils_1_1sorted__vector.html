<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>lxgui: lxgui::utils::sorted_vector&lt; T, Cmp &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">lxgui
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelxgui.html">lxgui</a></li><li class="navelem"><a class="el" href="namespacelxgui_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">sorted_vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classlxgui_1_1utils_1_1sorted__vector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">lxgui::utils::sorted_vector&lt; T, Cmp &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Sorted std::vector wrapper. This class is a light alternative to std::set. Inspired from: [1] www.lafstern.org/matt/col1.pdf.  
 <a href="classlxgui_1_1utils_1_1sorted__vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="utils__sorted__vector_8hpp_source.html">utils_sorted_vector.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for lxgui::utils::sorted_vector&lt; T, Cmp &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classlxgui_1_1utils_1_1sorted__vector.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9a4be03215c0441f516a38ddf1b81c82" id="r_a9a4be03215c0441f516a38ddf1b81c82"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a9a4be03215c0441f516a38ddf1b81c82">iterator</a> = typename base::iterator</td></tr>
<tr class="separator:a9a4be03215c0441f516a38ddf1b81c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea79fd8c8d75b153fa8ff98fefc6b23" id="r_a8ea79fd8c8d75b153fa8ff98fefc6b23"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a8ea79fd8c8d75b153fa8ff98fefc6b23">const_iterator</a> = typename base::const_iterator</td></tr>
<tr class="separator:a8ea79fd8c8d75b153fa8ff98fefc6b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d554a742ee0790a1399fe2cef2908a6" id="r_a4d554a742ee0790a1399fe2cef2908a6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a4d554a742ee0790a1399fe2cef2908a6">reverse_iterator</a> = typename base::reverse_iterator</td></tr>
<tr class="separator:a4d554a742ee0790a1399fe2cef2908a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28438f15bc671a2a66a181b76fbf79a7" id="r_a28438f15bc671a2a66a181b76fbf79a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a28438f15bc671a2a66a181b76fbf79a7">const_reverse_iterator</a> = typename base::const_reverse_iterator</td></tr>
<tr class="separator:a28438f15bc671a2a66a181b76fbf79a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3b3e069459672240d1806e701f59343b" id="r_a3b3e069459672240d1806e701f59343b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a3b3e069459672240d1806e701f59343b">sorted_vector</a> ()=default</td></tr>
<tr class="memdesc:a3b3e069459672240d1806e701f59343b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. Creates an empty vector.  <br /></td></tr>
<tr class="separator:a3b3e069459672240d1806e701f59343b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17acdfa9bff52fb6dd1cd4f2e414b27" id="r_ae17acdfa9bff52fb6dd1cd4f2e414b27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#ae17acdfa9bff52fb6dd1cd4f2e414b27">sorted_vector</a> (const <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">sorted_vector</a> &amp;s)=default</td></tr>
<tr class="memdesc:ae17acdfa9bff52fb6dd1cd4f2e414b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy another vector into this one.  <br /></td></tr>
<tr class="separator:ae17acdfa9bff52fb6dd1cd4f2e414b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a49277a135b0b75bf2655f8a51237f1" id="r_a7a49277a135b0b75bf2655f8a51237f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a7a49277a135b0b75bf2655f8a51237f1">sorted_vector</a> (<a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">sorted_vector</a> &amp;&amp;s)=default</td></tr>
<tr class="memdesc:a7a49277a135b0b75bf2655f8a51237f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move another <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html" title="Sorted std::vector wrapper. This class is a light alternative to std::set. Inspired from: [1] www....">sorted_vector</a> into this one. The other vector is left empty in the process, and all its content is transfered into this new one.  <br /></td></tr>
<tr class="separator:a7a49277a135b0b75bf2655f8a51237f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb4053653b975e80c2fc6a53506804f" id="r_aacb4053653b975e80c2fc6a53506804f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">sorted_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#aacb4053653b975e80c2fc6a53506804f">operator=</a> (const <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">sorted_vector</a> &amp;s)=default</td></tr>
<tr class="memdesc:aacb4053653b975e80c2fc6a53506804f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy another <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html" title="Sorted std::vector wrapper. This class is a light alternative to std::set. Inspired from: [1] www....">sorted_vector</a> into this one.  <br /></td></tr>
<tr class="separator:aacb4053653b975e80c2fc6a53506804f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470ad33aecba1ad35e20729d83a834d3" id="r_a470ad33aecba1ad35e20729d83a834d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">sorted_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a470ad33aecba1ad35e20729d83a834d3">operator=</a> (<a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">sorted_vector</a> &amp;&amp;s)=default</td></tr>
<tr class="memdesc:a470ad33aecba1ad35e20729d83a834d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move another vector into this one. The other vector is left empty in the process, and all its content is transfered into this new one.  <br /></td></tr>
<tr class="separator:a470ad33aecba1ad35e20729d83a834d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57555c300f6d189342cf53c45a4dece" id="r_aa57555c300f6d189342cf53c45a4dece"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#aa57555c300f6d189342cf53c45a4dece">sorted_vector</a> (const base &amp;s)</td></tr>
<tr class="memdesc:aa57555c300f6d189342cf53c45a4dece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a pre-built vector into this one. The provided vector must be sorted, and shall not contain any duplicate value.  <br /></td></tr>
<tr class="separator:aa57555c300f6d189342cf53c45a4dece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38d26b61ecc4c3b5c13e138c680075c" id="r_ad38d26b61ecc4c3b5c13e138c680075c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#ad38d26b61ecc4c3b5c13e138c680075c">sorted_vector</a> (base &amp;&amp;s)</td></tr>
<tr class="memdesc:ad38d26b61ecc4c3b5c13e138c680075c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a pre-built vector into this one. The provided vector must be sorted, and shall not contain any duplicate value. It is left empty in the process, and all its content is transfered into this new <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html" title="Sorted std::vector wrapper. This class is a light alternative to std::set. Inspired from: [1] www....">sorted_vector</a>.  <br /></td></tr>
<tr class="separator:ad38d26b61ecc4c3b5c13e138c680075c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0448a48e6264edff40bd957b2895be5c" id="r_a0448a48e6264edff40bd957b2895be5c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a0448a48e6264edff40bd957b2895be5c">sorted_vector</a> (const Cmp &amp;c)</td></tr>
<tr class="memdesc:a0448a48e6264edff40bd957b2895be5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, with comparator. Creates an empty vector and sets the comparator function.  <br /></td></tr>
<tr class="separator:a0448a48e6264edff40bd957b2895be5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeeacd90dd4bbbd9a4b8177f3d5e2bbf" id="r_adeeacd90dd4bbbd9a4b8177f3d5e2bbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#adeeacd90dd4bbbd9a4b8177f3d5e2bbf">sorted_vector</a> (std::initializer_list&lt; T &gt; l)</td></tr>
<tr class="memdesc:adeeacd90dd4bbbd9a4b8177f3d5e2bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an initializer list into this vector. The list need not be sorted.  <br /></td></tr>
<tr class="separator:adeeacd90dd4bbbd9a4b8177f3d5e2bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f6fb22dae9af94b8cad35220d2a6ca" id="r_ab1f6fb22dae9af94b8cad35220d2a6ca"><td class="memItemLeft" align="right" valign="top">Cmp &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#ab1f6fb22dae9af94b8cad35220d2a6ca">comparator</a> ()</td></tr>
<tr class="memdesc:ab1f6fb22dae9af94b8cad35220d2a6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the comparator object.  <br /></td></tr>
<tr class="separator:ab1f6fb22dae9af94b8cad35220d2a6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3549cea47ecf3dc7412e6d5a96af73d7" id="r_a3549cea47ecf3dc7412e6d5a96af73d7"><td class="memItemLeft" align="right" valign="top">const Cmp &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a3549cea47ecf3dc7412e6d5a96af73d7">comparator</a> () const</td></tr>
<tr class="memdesc:a3549cea47ecf3dc7412e6d5a96af73d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the comparator object.  <br /></td></tr>
<tr class="separator:a3549cea47ecf3dc7412e6d5a96af73d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae38e03f7be6ba454f9dd938d08df175" id="r_aae38e03f7be6ba454f9dd938d08df175"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aae38e03f7be6ba454f9dd938d08df175"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a9a4be03215c0441f516a38ddf1b81c82">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#aae38e03f7be6ba454f9dd938d08df175">insert</a> (U &amp;&amp;t)</td></tr>
<tr class="memdesc:aae38e03f7be6ba454f9dd938d08df175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the provided object in the vector, only if no object exists with the same key.  <br /></td></tr>
<tr class="separator:aae38e03f7be6ba454f9dd938d08df175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6d81c5545fb9c214d580716cace802" id="r_aab6d81c5545fb9c214d580716cace802"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aab6d81c5545fb9c214d580716cace802"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a9a4be03215c0441f516a38ddf1b81c82">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#aab6d81c5545fb9c214d580716cace802">insert_or_assign</a> (U &amp;&amp;t)</td></tr>
<tr class="memdesc:aab6d81c5545fb9c214d580716cace802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the provided object in the vector.  <br /></td></tr>
<tr class="separator:aab6d81c5545fb9c214d580716cace802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926ec015dccb6f13bb11ad726479b4b7" id="r_a926ec015dccb6f13bb11ad726479b4b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a9a4be03215c0441f516a38ddf1b81c82">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a926ec015dccb6f13bb11ad726479b4b7">erase</a> (<a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a9a4be03215c0441f516a38ddf1b81c82">iterator</a> iter)</td></tr>
<tr class="memdesc:a926ec015dccb6f13bb11ad726479b4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an element from this vector.  <br /></td></tr>
<tr class="separator:a926ec015dccb6f13bb11ad726479b4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e68457c32a7e276b4053139f4b4b65" id="r_a75e68457c32a7e276b4053139f4b4b65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a9a4be03215c0441f516a38ddf1b81c82">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a75e68457c32a7e276b4053139f4b4b65">erase</a> (<a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a9a4be03215c0441f516a38ddf1b81c82">iterator</a> first, <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a9a4be03215c0441f516a38ddf1b81c82">iterator</a> last)</td></tr>
<tr class="memdesc:a75e68457c32a7e276b4053139f4b4b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a range from this vector.  <br /></td></tr>
<tr class="separator:a75e68457c32a7e276b4053139f4b4b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683603c4a2d305eb6cec09f9ac7fbfe9" id="r_a683603c4a2d305eb6cec09f9ac7fbfe9"><td class="memTemplParams" colspan="2">template&lt;typename Key &gt; </td></tr>
<tr class="memitem:a683603c4a2d305eb6cec09f9ac7fbfe9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a9a4be03215c0441f516a38ddf1b81c82">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a683603c4a2d305eb6cec09f9ac7fbfe9">erase</a> (const Key &amp;k)</td></tr>
<tr class="memdesc:a683603c4a2d305eb6cec09f9ac7fbfe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an element from this vector by its key. The key can be a copy of the element itself, or any other object that is supported by the chosen comparison function. If no object is found with that key, this function does nothing.  <br /></td></tr>
<tr class="separator:a683603c4a2d305eb6cec09f9ac7fbfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef5dc9241a362c84a645604134be02d" id="r_a3ef5dc9241a362c84a645604134be02d"><td class="memTemplParams" colspan="2">template&lt;typename Key &gt; </td></tr>
<tr class="memitem:a3ef5dc9241a362c84a645604134be02d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a9a4be03215c0441f516a38ddf1b81c82">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a3ef5dc9241a362c84a645604134be02d">find</a> (const Key &amp;k)</td></tr>
<tr class="memdesc:a3ef5dc9241a362c84a645604134be02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an object in this vector by its key. The key can be a copy of the element itself, or any other object that is supported by the chosen comparison function. If no element is found, this function returns end().  <br /></td></tr>
<tr class="separator:a3ef5dc9241a362c84a645604134be02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250d78ff3309ffbfe1bd2679e9daef02" id="r_a250d78ff3309ffbfe1bd2679e9daef02"><td class="memTemplParams" colspan="2">template&lt;typename Key &gt; </td></tr>
<tr class="memitem:a250d78ff3309ffbfe1bd2679e9daef02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a8ea79fd8c8d75b153fa8ff98fefc6b23">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a250d78ff3309ffbfe1bd2679e9daef02">find</a> (const Key &amp;k) const</td></tr>
<tr class="memdesc:a250d78ff3309ffbfe1bd2679e9daef02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an object in this vector by its key. The key can be a copy of the element itself, or any other object that is supported by the chosen comparison function. If no element is found, this function returns end().  <br /></td></tr>
<tr class="separator:a250d78ff3309ffbfe1bd2679e9daef02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename Cmp = std::less&lt;T&gt;&gt;<br />
class lxgui::utils::sorted_vector&lt; T, Cmp &gt;</div><p>Sorted std::vector wrapper. This class is a light alternative to std::set. Inspired from: [1] www.lafstern.org/matt/col1.pdf. </p>
<p>The sorted vector achieves the same O(log(N)) look up complexity as std::set, but with a lower constant of proportionality thanks to the binary search algorithm (twice lower according to [1]). The fact that this container uses an std::vector internally also implies that it has the lowest possible memory usage.</p>
<p>On the other hand, it has worse insertion complexity (O(N), compared to the O(log(N)) of std::set). This drawback can be completely ignored if either:</p>
<ul>
<li>one does much more look-ups than insertions,</li>
<li>all the data are available when the vector is created, so that the insertions are all performed in one go,</li>
<li>and, even better, if one builds an already sorted std::vector and creates a <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html" title="Sorted std::vector wrapper. This class is a light alternative to std::set. Inspired from: [1] www....">sorted_vector</a> out of it.</li>
</ul>
<p>The elements of this container are sorted according to the Cmp template argument, which defaults to std::less&lt;T&gt; (i.e. the elements are sorted using operator&lt;()). One can provide a custom comparison functor if std::less is not desirable. Using a custom comparison functor can also allow to find elements by keys instead of their own value. For example, if T is</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>test { <span class="keywordtype">int</span> id; };</div>
</div><!-- fragment --><p>then one can use the following comparison functor:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>comp {</div>
<div class="line">    <span class="keywordtype">bool</span> operator() (<span class="keyword">const</span> test&amp; n1, <span class="keyword">const</span> test&amp; n2)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> n1.id &lt; n2.id;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> operator() (<span class="keyword">const</span> test&amp; n1, <span class="keywordtype">int</span> i)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> n1.id &lt; i;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> operator() (<span class="keywordtype">int</span> i, <span class="keyword">const</span> test&amp; n2)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> i &lt; n2.id;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>and use an integer as the key to find elements in the container</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>vec_t = <a class="code hl_class" href="classlxgui_1_1utils_1_1sorted__vector.html">sorted_vector&lt;test, comp&gt;</a>;</div>
<div class="line">vec_t vec;</div>
<div class="line"><span class="comment">// ... fill vec with some data ...</span></div>
<div class="line"><span class="comment">// Then find the element that has the &#39;id&#39; equal to 5</span></div>
<div class="line">vec_t::iterator it = vec.<a class="code hl_function" href="classlxgui_1_1utils_1_1sorted__vector.html#a3ef5dc9241a362c84a645604134be02d">find</a>(5);</div>
<div class="ttc" id="aclasslxgui_1_1utils_1_1sorted__vector_html"><div class="ttname"><a href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a></div><div class="ttdoc">Sorted std::vector wrapper. This class is a light alternative to std::set. Inspired from: [1] www....</div><div class="ttdef"><b>Definition</b> <a href="utils__sorted__vector_8hpp_source.html#l00069">utils_sorted_vector.hpp:69</a></div></div>
<div class="ttc" id="aclasslxgui_1_1utils_1_1sorted__vector_html_a3ef5dc9241a362c84a645604134be02d"><div class="ttname"><a href="classlxgui_1_1utils_1_1sorted__vector.html#a3ef5dc9241a362c84a645604134be02d">lxgui::utils::sorted_vector::find</a></div><div class="ttdeci">iterator find(const Key &amp;k)</div><div class="ttdoc">Find an object in this vector by its key. The key can be a copy of the element itself,...</div><div class="ttdef"><b>Definition</b> <a href="utils__sorted__vector_8hpp_source.html#l00210">utils_sorted_vector.hpp:210</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="utils__sorted__vector_8hpp_source.html#l00069">69</a> of file <a class="el" href="utils__sorted__vector_8hpp_source.html">utils_sorted_vector.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8ea79fd8c8d75b153fa8ff98fefc6b23" name="a8ea79fd8c8d75b153fa8ff98fefc6b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea79fd8c8d75b153fa8ff98fefc6b23">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::const_iterator =  typename base::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils__sorted__vector_8hpp_source.html#l00075">75</a> of file <a class="el" href="utils__sorted__vector_8hpp_source.html">utils_sorted_vector.hpp</a>.</p>

</div>
</div>
<a id="a28438f15bc671a2a66a181b76fbf79a7" name="a28438f15bc671a2a66a181b76fbf79a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28438f15bc671a2a66a181b76fbf79a7">&#9670;&#160;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::const_reverse_iterator =  typename base::const_reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils__sorted__vector_8hpp_source.html#l00077">77</a> of file <a class="el" href="utils__sorted__vector_8hpp_source.html">utils_sorted_vector.hpp</a>.</p>

</div>
</div>
<a id="a9a4be03215c0441f516a38ddf1b81c82" name="a9a4be03215c0441f516a38ddf1b81c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4be03215c0441f516a38ddf1b81c82">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::iterator =  typename base::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils__sorted__vector_8hpp_source.html#l00074">74</a> of file <a class="el" href="utils__sorted__vector_8hpp_source.html">utils_sorted_vector.hpp</a>.</p>

</div>
</div>
<a id="a4d554a742ee0790a1399fe2cef2908a6" name="a4d554a742ee0790a1399fe2cef2908a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d554a742ee0790a1399fe2cef2908a6">&#9670;&#160;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::reverse_iterator =  typename base::reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils__sorted__vector_8hpp_source.html#l00076">76</a> of file <a class="el" href="utils__sorted__vector_8hpp_source.html">utils_sorted_vector.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3b3e069459672240d1806e701f59343b" name="a3b3e069459672240d1806e701f59343b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b3e069459672240d1806e701f59343b">&#9670;&#160;</a></span>sorted_vector() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::sorted_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. Creates an empty vector. </p>

</div>
</div>
<a id="ae17acdfa9bff52fb6dd1cd4f2e414b27" name="ae17acdfa9bff52fb6dd1cd4f2e414b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17acdfa9bff52fb6dd1cd4f2e414b27">&#9670;&#160;</a></span>sorted_vector() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::sorted_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">sorted_vector</a>&lt; T, Cmp &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy another vector into this one. </p>

</div>
</div>
<a id="a7a49277a135b0b75bf2655f8a51237f1" name="a7a49277a135b0b75bf2655f8a51237f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a49277a135b0b75bf2655f8a51237f1">&#9670;&#160;</a></span>sorted_vector() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::sorted_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">sorted_vector</a>&lt; T, Cmp &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move another <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html" title="Sorted std::vector wrapper. This class is a light alternative to std::set. Inspired from: [1] www....">sorted_vector</a> into this one. The other vector is left empty in the process, and all its content is transfered into this new one. </p>

</div>
</div>
<a id="aa57555c300f6d189342cf53c45a4dece" name="aa57555c300f6d189342cf53c45a4dece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57555c300f6d189342cf53c45a4dece">&#9670;&#160;</a></span>sorted_vector() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::sorted_vector </td>
          <td>(</td>
          <td class="paramtype">const base &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a pre-built vector into this one. The provided vector must be sorted, and shall not contain any duplicate value. </p>

<p class="definition">Definition at line <a class="el" href="utils__sorted__vector_8hpp_source.html#l00109">109</a> of file <a class="el" href="utils__sorted__vector_8hpp_source.html">utils_sorted_vector.hpp</a>.</p>

</div>
</div>
<a id="ad38d26b61ecc4c3b5c13e138c680075c" name="ad38d26b61ecc4c3b5c13e138c680075c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38d26b61ecc4c3b5c13e138c680075c">&#9670;&#160;</a></span>sorted_vector() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::sorted_vector </td>
          <td>(</td>
          <td class="paramtype">base &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move a pre-built vector into this one. The provided vector must be sorted, and shall not contain any duplicate value. It is left empty in the process, and all its content is transfered into this new <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html" title="Sorted std::vector wrapper. This class is a light alternative to std::set. Inspired from: [1] www....">sorted_vector</a>. </p>

<p class="definition">Definition at line <a class="el" href="utils__sorted__vector_8hpp_source.html#l00117">117</a> of file <a class="el" href="utils__sorted__vector_8hpp_source.html">utils_sorted_vector.hpp</a>.</p>

</div>
</div>
<a id="a0448a48e6264edff40bd957b2895be5c" name="a0448a48e6264edff40bd957b2895be5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0448a48e6264edff40bd957b2895be5c">&#9670;&#160;</a></span>sorted_vector() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::sorted_vector </td>
          <td>(</td>
          <td class="paramtype">const Cmp &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor, with comparator. Creates an empty vector and sets the comparator function. </p>

<p class="definition">Definition at line <a class="el" href="utils__sorted__vector_8hpp_source.html#l00123">123</a> of file <a class="el" href="utils__sorted__vector_8hpp_source.html">utils_sorted_vector.hpp</a>.</p>

</div>
</div>
<a id="adeeacd90dd4bbbd9a4b8177f3d5e2bbf" name="adeeacd90dd4bbbd9a4b8177f3d5e2bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeeacd90dd4bbbd9a4b8177f3d5e2bbf">&#9670;&#160;</a></span>sorted_vector() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::sorted_vector </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write an initializer list into this vector. The list need not be sorted. </p>

<p class="definition">Definition at line <a class="el" href="utils__sorted__vector_8hpp_source.html#l00129">129</a> of file <a class="el" href="utils__sorted__vector_8hpp_source.html">utils_sorted_vector.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab1f6fb22dae9af94b8cad35220d2a6ca" name="ab1f6fb22dae9af94b8cad35220d2a6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f6fb22dae9af94b8cad35220d2a6ca">&#9670;&#160;</a></span>comparator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Cmp &amp; <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::comparator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the comparator object. </p>

<p class="definition">Definition at line <a class="el" href="utils__sorted__vector_8hpp_source.html#l00136">136</a> of file <a class="el" href="utils__sorted__vector_8hpp_source.html">utils_sorted_vector.hpp</a>.</p>

</div>
</div>
<a id="a3549cea47ecf3dc7412e6d5a96af73d7" name="a3549cea47ecf3dc7412e6d5a96af73d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3549cea47ecf3dc7412e6d5a96af73d7">&#9670;&#160;</a></span>comparator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Cmp &amp; <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::comparator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the comparator object. </p>

<p class="definition">Definition at line <a class="el" href="utils__sorted__vector_8hpp_source.html#l00141">141</a> of file <a class="el" href="utils__sorted__vector_8hpp_source.html">utils_sorted_vector.hpp</a>.</p>

</div>
</div>
<a id="a683603c4a2d305eb6cec09f9ac7fbfe9" name="a683603c4a2d305eb6cec09f9ac7fbfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683603c4a2d305eb6cec09f9ac7fbfe9">&#9670;&#160;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Key &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a9a4be03215c0441f516a38ddf1b81c82">iterator</a> <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase an element from this vector by its key. The key can be a copy of the element itself, or any other object that is supported by the chosen comparison function. If no object is found with that key, this function does nothing. </p>

<p class="definition">Definition at line <a class="el" href="utils__sorted__vector_8hpp_source.html#l00195">195</a> of file <a class="el" href="utils__sorted__vector_8hpp_source.html">utils_sorted_vector.hpp</a>.</p>

</div>
</div>
<a id="a75e68457c32a7e276b4053139f4b4b65" name="a75e68457c32a7e276b4053139f4b4b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e68457c32a7e276b4053139f4b4b65">&#9670;&#160;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a9a4be03215c0441f516a38ddf1b81c82">iterator</a> <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a9a4be03215c0441f516a38ddf1b81c82">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a9a4be03215c0441f516a38ddf1b81c82">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a range from this vector. </p>

<p class="definition">Definition at line <a class="el" href="utils__sorted__vector_8hpp_source.html#l00184">184</a> of file <a class="el" href="utils__sorted__vector_8hpp_source.html">utils_sorted_vector.hpp</a>.</p>

</div>
</div>
<a id="a926ec015dccb6f13bb11ad726479b4b7" name="a926ec015dccb6f13bb11ad726479b4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926ec015dccb6f13bb11ad726479b4b7">&#9670;&#160;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a9a4be03215c0441f516a38ddf1b81c82">iterator</a> <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a9a4be03215c0441f516a38ddf1b81c82">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase an element from this vector. </p>

<p class="definition">Definition at line <a class="el" href="utils__sorted__vector_8hpp_source.html#l00179">179</a> of file <a class="el" href="utils__sorted__vector_8hpp_source.html">utils_sorted_vector.hpp</a>.</p>

</div>
</div>
<a id="a3ef5dc9241a362c84a645604134be02d" name="a3ef5dc9241a362c84a645604134be02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef5dc9241a362c84a645604134be02d">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Key &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a9a4be03215c0441f516a38ddf1b81c82">iterator</a> <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an object in this vector by its key. The key can be a copy of the element itself, or any other object that is supported by the chosen comparison function. If no element is found, this function returns end(). </p>

<p class="definition">Definition at line <a class="el" href="utils__sorted__vector_8hpp_source.html#l00210">210</a> of file <a class="el" href="utils__sorted__vector_8hpp_source.html">utils_sorted_vector.hpp</a>.</p>

</div>
</div>
<a id="a250d78ff3309ffbfe1bd2679e9daef02" name="a250d78ff3309ffbfe1bd2679e9daef02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250d78ff3309ffbfe1bd2679e9daef02">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Key &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a8ea79fd8c8d75b153fa8ff98fefc6b23">const_iterator</a> <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an object in this vector by its key. The key can be a copy of the element itself, or any other object that is supported by the chosen comparison function. If no element is found, this function returns end(). </p>

<p class="definition">Definition at line <a class="el" href="utils__sorted__vector_8hpp_source.html#l00226">226</a> of file <a class="el" href="utils__sorted__vector_8hpp_source.html">utils_sorted_vector.hpp</a>.</p>

</div>
</div>
<a id="aae38e03f7be6ba454f9dd938d08df175" name="aae38e03f7be6ba454f9dd938d08df175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae38e03f7be6ba454f9dd938d08df175">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a9a4be03215c0441f516a38ddf1b81c82">iterator</a>, bool &gt; <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the provided object in the vector, only if no object exists with the same key. </p>
<dl class="section note"><dt>Note</dt><dd>If an object already exists with the same key, the vector is unchanged and the boolean in the returned pair is set to false. Else, the vector is modified and the boolean is set to true. </dd></dl>

<p class="definition">Definition at line <a class="el" href="utils__sorted__vector_8hpp_source.html#l00152">152</a> of file <a class="el" href="utils__sorted__vector_8hpp_source.html">utils_sorted_vector.hpp</a>.</p>

</div>
</div>
<a id="aab6d81c5545fb9c214d580716cace802" name="aab6d81c5545fb9c214d580716cace802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6d81c5545fb9c214d580716cace802">&#9670;&#160;</a></span>insert_or_assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html#a9a4be03215c0441f516a38ddf1b81c82">iterator</a> <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the provided object in the vector. </p>
<dl class="section note"><dt>Note</dt><dd>If an object already exists with the same key, it is destroyed and replaced by this one. </dd></dl>

<p class="definition">Definition at line <a class="el" href="utils__sorted__vector_8hpp_source.html#l00171">171</a> of file <a class="el" href="utils__sorted__vector_8hpp_source.html">utils_sorted_vector.hpp</a>.</p>

</div>
</div>
<a id="aacb4053653b975e80c2fc6a53506804f" name="aacb4053653b975e80c2fc6a53506804f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb4053653b975e80c2fc6a53506804f">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">sorted_vector</a> &amp; <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">sorted_vector</a>&lt; T, Cmp &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy another <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html" title="Sorted std::vector wrapper. This class is a light alternative to std::set. Inspired from: [1] www....">sorted_vector</a> into this one. </p>

</div>
</div>
<a id="a470ad33aecba1ad35e20729d83a834d3" name="a470ad33aecba1ad35e20729d83a834d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470ad33aecba1ad35e20729d83a834d3">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cmp  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">sorted_vector</a> &amp; <a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">lxgui::utils::sorted_vector</a>&lt; T, Cmp &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlxgui_1_1utils_1_1sorted__vector.html">sorted_vector</a>&lt; T, Cmp &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move another vector into this one. The other vector is left empty in the process, and all its content is transfered into this new one. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/lxgui/lxgui/include/lxgui/<a class="el" href="utils__sorted__vector_8hpp_source.html">utils_sorted_vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 21 2025 18:06:24 for lxgui by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
