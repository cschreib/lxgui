<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gui: lxgui Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gui
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">lxgui Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacelxgui_1_1gui"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelxgui_1_1gui.html">gui</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelxgui_1_1input"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelxgui_1_1input.html">input</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelxgui_1_1lua"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelxgui_1_1lua.html">lua</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelxgui_1_1utils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelxgui_1_1utils.html">utils</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelxgui_1_1xml"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelxgui_1_1xml.html">xml</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6f118aebf6804d5d44937e874e1ab8e5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelxgui.html#a6f118aebf6804d5d44937e874e1ab8e5">ulong</a> = unsigned long</td></tr>
<tr class="separator:a6f118aebf6804d5d44937e874e1ab8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad60a3835af109b1519d66daff76eb44"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelxgui.html#aad60a3835af109b1519d66daff76eb44">uint</a> = unsigned int</td></tr>
<tr class="separator:aad60a3835af109b1519d66daff76eb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b9c3e081eb31ae66e2703874109011"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelxgui.html#ad8b9c3e081eb31ae66e2703874109011">uchar</a> = unsigned char</td></tr>
<tr class="separator:ad8b9c3e081eb31ae66e2703874109011"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>AFrame} with a button that can be clicked. This class can handle three different states: "normal", "pushed" and "disabled". You can provide a different texture for each of these states, and two different fontstrings for "normal" and "disabled".</p>
<p>In addition, you can provide another texture/fontstring for the "highlight" state (when the mouse is over the button widget).</p>
<p>Note that there is no fontstring for the "pushed" state: in this case, the "normal" font is rendered with a slight offset that you are free to define.</p>
<p>Note that aButton} hasFrame:enable_mouse} set to <code>true</code> by default.</p>
<p><b>Events.</b> Hard-coded events available to allButton}s, in addition to those fromFrame}:</p>
<ul>
<li><code>OnClick</code>: Triggered when the button is clicked, either when Button:click} is called, or after the mouse is released after a click over the button.</li>
<li><code>OnDoubleClick</code>: Triggered when the button is double-clicked.</li>
<li><code>OnEnable</code>: Triggered byButton:enable}.</li>
<li><code>OnDisable</code>: Triggered byButton:disable}.</li>
</ul>
<p>Inherits all methods from:UIObject},Frame}.</p>
<p>Child classes:CheckButton}. @classmod Button</p>
<p>AButton} with two additional states: checked and unchecked. This widget works exactly like a classicButton}, but is has two additional special textures for the check sign.</p>
<p>Inherits all methods from:UIObject},Frame},Button}.</p>
<p>Child classes: none. @classmod CheckButton</p>
<p>AFrame} with an editable text box. This frame lets the user input arbitrary text into a box, which can be read and used by the rest of the interface. The text box can be either single-line or multi-line. Text can be selected by holding the Shift key, and natural navigation is available with the Left, Right, Up, Down, Home, End, Page Up, and Page Down keys. Copy and paste operations are also supported. The edit box can also remember the history of previously entered values or commands, which can be brought back at will. The characters entered as handled by the operating system, hence this class will use whatever keyboard layout is currently in use. Finally, the edit box can be configured to only accept numeric values (of either sign, or positive only), and to hide the input characters to simulate a password box (no encryption or other safety measure is used).</p>
<p>Note that anEditBox} hasFrame:enable_mouse} set to <code>true</code> andFrame:register_for_drag} set to <code>"LeftButton"</code> by default.</p>
<p><b>Events.</b> Hard-coded events available to allEditBox}es, in addition to those fromFrame}:</p>
<ul>
<li><code>OnChar</code>: Triggered whenever a new character is added to the edit box. Will always be preceeded by <code>OnTextChanged</code>.</li>
<li><code>OnCursorChanged</code>: Triggered whenever the position of the edit cursor is changed (not yet implemented).</li>
<li><code>OnEditFocusGained</code>: Triggered when the edit box gains focus, seeFocusFrame:set_focus}.</li>
<li><code>OnEditFocusLost</code>: Triggered when the edit box looses focus, seeFocusFrame:set_focus}.</li>
<li><code>OnEnterPressed</code>: Triggered when the <code>Enter</code> (or <code>Return</code>) key is pressed while the edit box is focussed. This captures both the main keyboard key and the smaller one on the numpad.</li>
<li><code>OnEscapePressed</code>: Triggered when the <code>Escape</code> key is <em>released</em> while the edit box is focussed.</li>
<li><code>OnSpacePressed</code>: Triggered when the <code>Space</code> key is pressed while the edit box is focussed.</li>
<li><code>OnTabPressed</code>: Triggered when the <code>Tab</code> key is pressed while the edit box is focussed.</li>
<li><code>OnUpPressed</code>: Triggered when the <code>Up</code> key is pressed while the edit box is focussed.</li>
<li><code>OnDownPressed</code>: Triggered when the <code>Down</code> key is pressed while the edit box is focussed.</li>
<li><code>OnTextChanged</code>: Triggered whenever the text contained in the edit box changes (character added or deleted, text set or pasted, etc.).</li>
<li><code>OnTextSet</code>: Triggered byEditBox:set_text}. Will always be followed by <code>OnTextChanged</code>.</li>
</ul>
<p>Inherits all methods from:UIObject},Frame},FocusFrame}.</p>
<p>Child classes: none. @classmod EditBox</p>
<p>AFrame} that can receive and loose focus. A typical usage example is theEditBox}.</p>
<p>Inherits all methods from:UIObject},Frame}.</p>
<p>Child classes:EditBox}. @classmod FocusFrame</p>
<p>ALayeredRegion} that can draw text on the screen. This class holds a string and a reference to a font, which is used to draw the string on the screen. The appearance of the string can be changed (font, size, color, alignment, wrapping). In addition, it is possible to change the color of a portion of the string, for example to highlight a particular name.</p>
<p><b>Sizing.</b> TheFontString} class has a special property when it comes to determining the size of its region on the screen, hence how other object anchor to it, and how it anchors to other objects. See the documentation forUIObject} for more information on anchors. While otherUIObject}s must either have a fixed size or more than two anchors constraining their size, theFontString} does not. If only one anchor is specified, the width and height of theFontString} will be determined by the area occupied by the displayed text, however long and tall this may be. If the width is already constrained by the fixed size or anchors, then the text will word wrap (if allowed) and the FontString}'s height will be as tall as the height of the wrapped text. Finally, if both the width and height are constrained by fixed sizes or anchors, the text will simply word wrap (if allowed) and be cut to fit in the specified area.</p>
<p>Inherits all methods from:UIObject},LayeredRegion}.</p>
<p>Child classes: none. @classmod FontString</p>
<p>AUIObject} that can contain other objects and react to events. This class, which is at the core of the UI design, can contain otherFrame}s as "children", andLayeredRegion}s sorted by layers (text, images, ...). A frame can also react to events, and register callbacks to be executed on particular events (key presses, etc.) or on every tick.</p>
<p>Each frame has an optional "title region", which can be used to define and draw a title bar. This title bar can then be used to move the frame around the screen using mouse click and drag. Furthermore, frames have optional support for resizing by click and drag on corners or edges (opt in).</p>
<p>Frames can either move freely on the screen, or be "clamped" to the screen so they cannot be partly outside of their render area.</p>
<p><b>Rendering.</b> Frames are grouped into different "strata", which are rendered sequentially. Frames in a high strata will always be rendered above frames in a low strata. Then, within a strata, frames are further sorted by "level"; within this particular strata, a frame with a high level will always be rendered above all frames with a lower level, but it will still remain below other frames in a higher strata. The level of a frame is automatically set to the maximum level inside the strata when the frame is clicked, which effectively brings the frame to the front.</p>
<p><b>Children and regions.</b> When a frame is hidden, all its children and regions will also be hidden. Likewise, deleting a frame will automatically delete all its children and regions, unless they are detached first. Other than this, children and regions do not need to be located inside the frame; this is controlled purely by their anchors. Therefore, if a child is not anchored to its parent, moving the parent will not automatically move the child.</p>
<p><b>Events.</b> Frames can react to events. For this to happen, a callback function must be registered to handle the corresponding event. There are two types of events. First: hard-coded UI events such as <code>OnKeyPress</code> or <code>OnUpdate</code>, which are automatically triggered by lxgui. Second: generic events, which can be triggered from various sources and all forwarded to the <code>OnEvent</code> callback. Generic events are typically generated by whatever application is being driven by lxgui (i.e., your game), and they enable application-specific behavior (for example: changing the UI when the player is under attack will likely require an <code>"UNDER_ATTACK"</code> event).</p>
<p>To use the first type of events (hard-coded events), all you have to do in general is register a callback function usingFrame:set_script}. However, some hard-coded events require explicit enabling. In particular:</p>
<ul>
<li>Events related to keyboard input (<code>OnKeyDown</code>, <code>OnKeyUp</code>) require Frame:enable_keyboard}.</li>
<li>Events related to mouse input (<code>OnDragStart</code>, <code>OnDragStop</code>,<code>OnEnter</code>, <code>OnLeave</code>, <code>OnMouseUp</code>, <code>OnMouseDown</code>, <code>OnMouseWheel</code>, <code>OnReceiveDrag</code>) requireFrame:enable_mouse}.</li>
</ul>
<p>To use the second type of events (generic events), you have to register a callback for <code>OnEvent</code> <em>and</em> register the frame for each generic event you wish to listen to. This is done withFrame:register_event}.</p>
<p>Some events provide arguments to the registered callback function. For example, the application can fire a <code>"UNIT_ATTACKED"</code> event when a unit is under attack, and pass the ID of the attacked unit as a first argument, and the ID of the attacker as a second argument. If a callback function is registered usingFrame:set_script}, these arguments can be handled and named like regular function parameters. In XML callback handlers, they can be accessed with the hard-coded generic names <code>arg1</code>, <code>arg2</code>, etc.</p>
<p>Hard-coded events available to allFrame}s:</p>
<ul>
<li><code>OnDragStart</code>: Triggered when one of the mouse button registered for dragging (seeFrame:register_for_drag}) has been pressed inside the area of the screen occupied by the frame, and a mouse movement is first recorded.</li>
<li><code>OnEnter</code>: Triggered when the mouse pointer enters into the area of the screen occupied by the frame. Note: this only takes into account the position and size of the frame and its title region, but not the space occupied by its children or layered regions. Will not trigger if the frame is hidden.</li>
<li><code>OnEvent</code>: Triggered when a registered generic event occurs. See Frame:register_event}. To allow distinguishing which event has just been fired, the registered callback function is always provided with a first argument that is set to a string matching the event name. Further arguments can be passed to the callback and are handled as for other events.</li>
<li><code>OnHide</code>: Triggered whenUIObject:hide} is called, or when the frame is hidden indirectly (for example if its parent is itself hidden). This will only fire if the frame was previously shown.</li>
<li><code>OnKeyDown</code>: Triggered when any keyboard key is pressed. Will not trigger if the frame is hidden. This event provides two arguments to the registered callback: a number identifying the key, and the human-readable name of the key.</li>
<li><code>OnKeyUp</code>: Triggered when any keyboard key is released. Will not trigger if the frame is hidden. This event provides two arguments to the registered callback: a number identifying the key, and the human-readable name of the key.</li>
<li><code>OnLeave</code>: Triggered when the mouse pointer leaves the area of the screen occupied by the frame. Note: this only takes into account the position and size of the frame and its title region, but not the space occupied by its children or layered regions. Will not trigger if the frame is hidden, unless the frame was just hidden with the mouse previously inside the frame.</li>
<li><code>OnLoad</code>: Triggered just after the frame is created. This is where you would normally register for events and specific inputs, set up initial states for extra logic, or do localization. When this event is triggered, you can assume that all the frame's regions and children have already been loaded. Other frames and other regions may not, however, hence they must not be refered to (directly or indirectly).</li>
<li><code>OnMouseDown</code>: Triggered when any mouse button is pressed. Will not trigger if the frame is hidden. This event provides one argument to the registered callback: a string identifying the mouse button (<code>"LeftButton"</code>, <code>"RightButton"</code>, or <code>"MiddleButton"</code>).</li>
<li><code>OnMouseUp</code>: Triggered when any mouse button is released. Will not trigger if the frame is hidden. This event provides one argument to the registered callback: a string identifying the mouse button (<code>"LeftButton"</code>, <code>"RightButton"</code>, or <code>"MiddleButton"</code>).</li>
<li><code>OnMouseWheel</code>: Triggered when the mouse wheel is moved. This event provides one argument to the registered callback: a number indicating by how many "notches" the wheel has turned in this event. A positive value means the wheel has been moved "away" from the user (this would normally scroll <em>up</em> in a document).</li>
<li><code>OnReceiveDrag</code>: Triggered when the mouse pointer was previously dragged onto the frame, and when one of the mouse button registered for dragging (seeFrame:register_for_drag}) is released. This enables the "drop" in "drag and drop" operations.</li>
<li><code>OnShow</code>: Triggered whenUIObject:show} is called, or when the frame is shown indirectly (for example if its parent is itself shown). This will only fire if the frame was previously hidden.</li>
<li><code>OnSizeChanged</code>: Triggered whenever the size of the frame changes, either directly or indirectly. Be very careful not to call any function that could change the size of the frame inside this callback, as this would generate an infinite loop.</li>
<li><code>OnUpdate</code>: Triggered on every tick of the game loop. This event provides one argument to the registered callback: a floating point number indicating how much time has passed since the last call to <code>OnUpdate</code> (in seconds). For optimal performance, prefer using other events types whenever possible. <code>OnUpdate</code> callbacks will be executed over and over again, and can quickly consume a lot of resources if user unreasonably. If you have to use <code>OnUpdate</code>, you can mitigate performance problems by artificially reducing the update rate: let the callback function only accumulate the time passed, and wait until enough time has passed (say, half a second) to execute any expensive operation. Then reset the accumulated time, and wait again.</li>
</ul>
<p>Generic events fired natively by lxgui:</p>
<ul>
<li><code>"LUA_ERROR"</code>: Triggered whenever a callback function or an addon script file generates a Lua error. This event provides one argument to the registered callback: a string containing the error message.</li>
<li><code>"ADDON_LOADED"</code>: Triggered when an addon is fully loaded. This event provides one argument to the registered callback: a string containing the name of the loaded addon.</li>
<li><code>"ENTERING_WORLD"</code>: Triggered once at the start of the program, at the end of the first update tick.</li>
</ul>
<p><b>Virtual frames.</b> Virtual frames are not displayed on the screen, and technically are not part of the interface. They are only available as "templates" that can be reused by other (virtual or non-virtual) frames. This is useful for defining a few frame templates with a particular style, and then reuse these templates across the interface to ensure a consistent look. When inheriting from a virtual frame, the inheriting frame will copy all the registered callbacks, all the child frames, and all the layered regions of the virtual frame.</p>
<p>Inherits all methods from:UIObject}.</p>
<p>Child classes:Button},CheckButton},FocusFrame},EditBox}, ScrollFrame},Slider},StatusBar}. @classmod Frame</p>
<p>AUIObject} that can be rendered in a layer. LayeredRegions can display content on the screen (texture, texts, 3D models, ...) and must be contained inside a layer, within aFrame} object. The frame will then render all its layered regions, sorted by layers.</p>
<p>Layered regions cannot themselves react to events; this must be taken care of by the parentFrame}.</p>
<p>Inherits all methods from:UIObject}.</p>
<p>Child classes:FontString},Texture}. @classmod LayeredRegion</p>
<p>Global functions for interacting with the GUI. The functions listed on this page are registered in the Lua state as globals, and as such are accessible from anywhere automatically. They offer various functionalities for creating or destroyingFrame}s, and accessing a few other global properties or objects.</p>
<p>@module Manager</p>
<p>AFrame} with scrollable content. This frame has a special child frame, the "scroll child". The scroll child is rendered on a separate render target, which is then rendered on the screen. This allows clipping the content of the scroll child and only display a portion of it (as if scrolling on a page). The displayed portion is controlled by the scroll value, which can be changed in both the vertical and horizontal directions.</p>
<p>By default, the mouse wheel movement will not trigger any scrolling; this has to be explicitly implemented using the <code>OnMouseWheel</code> callback and theScrollFrame:set_horizontal_scroll} function.</p>
<p><b>Events.</b> Hard-coded events available to allScrollFrame}s, in addition to those fromFrame}:</p>
<ul>
<li><code>OnHorizontalScroll</code>: Triggered byScrollFrame:set_horizontal_scroll}.</li>
<li><code>OnScrollRangeChanged</code>: Triggered whenever the range of the scroll value changes. This happens either when the size of the scrollable content changes, or when the size of the scroll frame changes.</li>
<li><code>OnVerticalScroll</code>: Triggered byScrollFrame:set_vertical_scroll}.</li>
</ul>
<p>Inherits all methods from:UIObject},Frame}.</p>
<p>Child classes: none. @classmod ScrollFrame</p>
<p>AFrame} with a movable texture. This frame contains a special texture, the "slider thumb". It can be moved along a single axis (X or Y) and its position can be used to represent a value (for configuration menus, or scroll bars).</p>
<p><b>Events.</b> Hard-coded events available to allSlider}s, in addition to those fromFrame}:</p>
<ul>
<li><code>OnValueChanged</code>: Triggered whenever the value controlled by the slider changes. This is triggered whenever the user moves the slider thumb, and bySlider:set_value}. This can also be triggered bySlider:set_min_value},Slider:set_max_value}, Slider:set_min_max_values}, andSlider:set_value_step} if the previous value would not satisfy the new constraints.</li>
</ul>
<p>Inherits all methods from:UIObject},Frame}.</p>
<p>Child classes: none. @classmod Slider</p>
<p>AFrame} representing a variable-length bar. This frame has three main properties: a minimum value, a maximum value, and a current value that must be contained between the minimum and maximum values. The frame will render a textured bar that will either be full, empty, or anything in between depending on the current value.</p>
<p>This can be used to display health bars, or progress bars.</p>
<p><b>Events.</b> Hard-coded events available to allStatusBar}s, in addition to those fromFrame}:</p>
<ul>
<li><code>OnValueChanged</code>: Triggered whenever the value represented by the status bar changes. This is triggered byStatusBar:set_value}. This can also be triggered byStatusBar:set_min_max_values} if the previous value would not satisfy the new constraints.</li>
</ul>
<p>Inherits all methods from:UIObject},Frame}.</p>
<p>Child classes: none. @classmod StatusBar</p>
<p>ALayeredRegion} that can draw images and colored rectangles. This object contains either a texture taken from a file, or a plain color (possibly with a different color on each corner).</p>
<p>Inherits all methods from:UIObject},LayeredRegion}.</p>
<p>Child classes: none. @classmod Texture</p>
<p>The base class of all elements in the GUI. Objects of this class offers core functionalities needed by every element of the interface. They have a name, and a corresponding variable created in Lua to access them. They can have a parentFrame}. They can be placed on the screen at an absolute position, or relative to otherUIObject}s. They can be shown or hidden.</p>
<p>Apart form this, aUIObject} does not contain anything, nor can it display anything on the screen. Any functionality beyond the list above is implemented in specialized subclasses (see the full list below).</p>
<p><b>Interaction between C++, Lua, and XML.</b> When aUIObject} is created, it must be given a name, for example <code>"PlayerHealthBar"</code>. For as long as the object lives, this name will be used to refer to it. In particular, as soon as the object is created, regardless of whether this was done in C++, XML, or Lua, a new variable will be created in the Lua state with the exact same name, <code>PlayerHealthBar</code>. This variable is a reference to theUIObject}, and can be used to interact with it dynamically. Because of this, each object must have a unique name, otherwise it could not be accessible from Lua.</p>
<p>Note: Although you can destroy this Lua variable by setting it to nil, this is not recommended: the object will <em>not</em> be destroyed (nor garbage-collected) because it still exists in the C++ memory space. The only way to truly destroy an object is to callManager.delete_frame} (forFrame}s only). Destroying and creating objects has a cost however. If the object is likely to reappear later with the same content, simply hide it and show it again later on. If the content may change, you can also recycle the object, i.e., keep it alive and simply change its content when it later reappears.</p>
<p><b>Parent-child relationship.</b> Parents ofUIObject}s areFrame}s. See theFrame} class documentation for more information. One important aspect of the parent-child relationship is related to the object name. If a UIObject} has a parent, it can be given a name starting with <code>"$parent"</code>. The name of the parent will automatically replace the <code>"$parent"</code> string. For example, if an object is named <code>"$parentButton"</code> and its parent is named <code>"ErrorMessage"</code>, the final name of the object will be <code>"ErrorMessageButton"</code>. It can be accessed from the Lua state as <code>ErrorMessageButton</code>, or as <code>ErrorMessage.Button</code>. Note that this is totally dynamic: if you later change the parent of this button to be another frame, for example <code>"ExitDialog"</code> its name will naturally change to <code>"ExitDialogButton"</code>, and it can be accessed from Lua as <code>ExitDialogButton</code>, or as <code>ExitDialog.Button</code>. This is particularly powerful for writing generic code which does not rely on the full names of objects, only on their child-parent relationship.</p>
<p><b>Positioning.</b>UIObject}s have a position on the screen, but this is not parametrized as a simple pair of X and Y coordinates. Instead, objects are positioned based on a list of "anchors". Anchors are links between objects, which force one edge or one corner of a given object to match with the edge or corner of another object. For example, given two objects A and B, you can create an anchor that links the top-left corner of A to the top-left corner of B. The position of A will automatically be linked to the position of B, hence if B moves, A will follow. To further refine this positioning, you can specify anchor offsets: for example, you may want A's top-left corner to be shifted from B's top-left corner by two pixels in the X direction, and five in the Y direction. This offset can be defined either as an absolute number of pixels, or as a relative fraction of the size of the object being anchored to. For example, you can specify that A's top-left corner links to B's top-left corner, with an horizontal offset equal to 30% of B's width. Read the "Anchors" section below for more information.</p>
<p>An object which has no anchor will be considered "invalid" and will not be displayed.</p>
<p><b>Sizing.</b> There are two ways to specify the size of aUIObject}. The first and most straightforward approach is to directly set its width and/or height. This must be specified as an absolute number of pixels. The second and more versatile method is to use more than one anchor for opposite sides of the object, for example an anchor for the "left" and another for the "right" edge. This will implicitly give a width to the object, depending on the position of the other objects to which it is anchored. Anchors will always override the absolute width and height of an object if they provide any constraint on the extents of the object in a given dimension.</p>
<p>An object which has neither a fixed absolute size, nor has it size implicitly constrained by anchors, is considered "invalid" and will not be displayed.</p>
<p><b>Anchors.</b> There are nine available anchor points:</p>
<ul>
<li><code>TOPLEFT</code>: constrains the max Y and min X.</li>
<li><code>TOPRIGHT</code>: constrains the max Y and max X.</li>
<li><code>BOTTOMLEFT</code>: constrains the min Y and min X.</li>
<li><code>BOTTOMRIGH</code>: constrains the min Y and max X.</li>
<li><code>LEFT</code>: constrains the min X and the midpoint in Y.</li>
<li><code>RIGHT</code>: constrains the max X and the midpoint in Y.</li>
<li><code>TOP</code>: constrains the max Y and the midpoint in X.</li>
<li><code>BOTTOM</code>: constrains the min Y and the midpoint in X.</li>
<li><code>CENTER</code>: constrains the midpoint in X and Y.</li>
</ul>
<p>If you specify two constraints on the same point (for example: <code>TOPLEFT</code> and <code>BOTTOMLEFT</code> both constrain the min X coordinate), the most stringent constraint always wins. Constraints on the midpoints are more subtle however, as they will always be discarded when both the min and max are constrained. For example, consider an object <code>A</code> of fixed size 30x30 and some other object <code>B</code> of fixed size 40x40. If we anchor the <code>RIGHT</code> of <code>A</code> to the <code>LEFT</code> of <code>B</code>, <code>A</code>'s <em>vertical</em> center will be automatically aligned with <code>B</code>'s vertical center. This is the effect of the midpoint constraint. Now, if we further anchor the <code>TOP</code> of <code>A</code> to the <code>TOP</code> of <code>B</code>, we have more than one anchor constraining the vertical extents of <code>A</code> (see "Sizing" above), therefore <code>A</code>'s fixed height of 30 pixels will be ignored from now on. It will shrink to a height of 20 pixels, i.e., the distance between <code>B</code>'s top edge and its vertical center. Finally, if we further anchor the <code>BOTTOM</code> of <code>A</code> to the <code>BOTTOM</code> of <code>B</code>, the constraint on <code>A</code>'s midpoint will be ignored: <code>A</code> will be enlarged to a height of 40 pixels, i.e., the distance between <code>B</code>'s top and bottom edges.</p>
<p>Inherits all methods from: none.</p>
<p>Child classes:Frame},LayeredRegion},FontString},Texture}, Button},CheckButton},FocusFrame},EditBox},ScrollFrame}, Slider},StatusBar}. @classmod UIObject </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ad8b9c3e081eb31ae66e2703874109011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b9c3e081eb31ae66e2703874109011">&#9670;&nbsp;</a></span>uchar</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelxgui.html#ad8b9c3e081eb31ae66e2703874109011">lxgui::uchar</a> = typedef unsigned char</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8hpp_source.html#l00010">10</a> of file <a class="el" href="utils_8hpp_source.html">utils.hpp</a>.</p>

</div>
</div>
<a id="aad60a3835af109b1519d66daff76eb44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad60a3835af109b1519d66daff76eb44">&#9670;&nbsp;</a></span>uint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelxgui.html#aad60a3835af109b1519d66daff76eb44">lxgui::uint</a> = typedef unsigned int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8hpp_source.html#l00009">9</a> of file <a class="el" href="utils_8hpp_source.html">utils.hpp</a>.</p>

</div>
</div>
<a id="a6f118aebf6804d5d44937e874e1ab8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f118aebf6804d5d44937e874e1ab8e5">&#9670;&nbsp;</a></span>ulong</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelxgui.html#a6f118aebf6804d5d44937e874e1ab8e5">lxgui::ulong</a> = typedef unsigned long</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8hpp_source.html#l00008">8</a> of file <a class="el" href="utils_8hpp_source.html">utils.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 11 2021 07:44:01 for gui by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
